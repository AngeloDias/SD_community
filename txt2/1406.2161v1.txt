extend the tableaux method to the full language of DL-PA (Section 5) and then show
an algorithm implementing it and that works in time exponential (Section 6). Section 7
discusses some issues and concludes the paper.3

2 Dynamic Logic of Propositional Assignments
2.1 Syntax
The vocabulary of DL-PA contains a countable set P of propositional variables. From
this set, we build the set A of propositional assignments, which are the atomic programs
of the language. Each propositional assignment is a non-empty finite partial function
from P to {⊥, ⊤}.4
The language L of DL-PA is the the set of formulas ϕ defined by the BNF:
ϕ F p | ¬ϕ | ϕ ∧ ϕ | [π]ϕ
π F α | π; π | π ∪ π | π∗ | ϕ?
where p ranges over P and α ranges over A.
To ease notation and readability of programs, we write +p for (p, ⊤) and −p for
(p, ⊥). Moreover, we sometimes “forget” some parentheses and curly braces when writing propositional assignments. As a result, the formula [{(p, ⊤), (q, ⊥)}]ϕ is rather noted
[+p, −q]ϕ. In some places, we use the expression ±p to talk economically about +p and
−p at the same time.
The complex programs of DL-PA are constructed as in Dynamic Propositional
Logic (PDL) [8]. As well as in PDL, formulas of the form [π]ϕ are read “after every
possible execution of π, ϕ is true”.
We also use the common abbreviations for the connectives ⊤, ⊥, ∨, → and ↔. The
formula hπiϕ abbreviates ¬[π]¬ϕ. The star-free fragment of L is the fragment without
the Kleene star operator ∗ and is noted L−∗ .
The length of a formula or a program, given by the function len, is the number of
atoms and connectives in the formula or the program. Table 1 defines it formally.
The closure of ϕ is the set cl(ϕ) defined in Table 2. This is almost the same as the
Fisher-Ladner closure [5], which is used to show decidability and complexity results
for PDL. But since the atomic programs of DL-PA are sets of assignments, there is a
difference here in the definition of cl ([α]ϕ). It takes into account the assignments by
adding the domain of the atomic program α.
3
4

Proofs of the important theorems are in the appendix.
We note that the original language in [2] is slightly more restrictive: α only assigns a single
propositional variable. But, as shown in this paper, it does not change the known decidability
and complexity results.

2

len(α) = | dom(α)|

len(p) = 1

len(π1 ; π2 ) = 1 + len(π1 ) + len(π2 )

len(¬ϕ) = 1 + len(ϕ)

len(π1 ∪ π2 ) = 1 + len(π1 ) + len(π2 )

len(ϕ1 ∧ ϕ2 ) = 1 + len(ϕ1 ) + len(ϕ2 )

len(π∗ ) = 1 + len(π)

len([π]ϕ) = 1 + len(π) + len(ϕ)

len(ϕ?) = 1 + len(ϕ)
Table 1. Length

cl ([α]ϕ) = {[α]ϕ} ∪ dom(α)

cl(p) = {p}


cl ([π1 ; π2 ]ϕ) = {[π1 ; π2 ]ϕ} ∪ cl ([π1 ][π2 ]ϕ)

cl(¬ϕ) = {¬ϕ} ∪ cl(ϕ)
cl(ϕ1 ∧ ϕ2 ) = {ϕ1 ∧ ϕ2 } ∪ cl(ϕ1 ) ∪ cl(ϕ2 )

cl ([π1 ∪ π2 ]ϕ) = {[π1 ∪ π2 ]ϕ} ∪ cl ([π1 ]ϕ) ∪ cl ([π2 ]ϕ)
cl ([π∗ ]ϕ) = {[π∗ ]ϕ} ∪ cl ([π][π∗ ]ϕ)



cl([π]ϕ) = cl ([π]ϕ) ∪ cl(ϕ)

cl ([ϕ1 ?]ϕ2 ) = {[ϕ1 ?]ϕ2 } ∪ cl(ϕ1 )
Table 2. Closure

The extended closure of ϕ is the set cl+ (ϕ) containing cl(ϕ) and the negations of its
formulas, i.e., cl+ (ϕ) = cl(ϕ) ∪ {¬ψ : ψ ∈ cl(ϕ)}. To ease notation, we sometimes use Pϕ
to denote the set of propositional variables occurring in ϕ, i.e. Pϕ = P ∩ cl(ϕ).
The lemma below can be proved with an easy induction on the length of formulas
and programs.
Lemma 1.
1. card(cl ([π]ϕ)) ≤ len([π]ϕ)
2. card(cl(ϕ)) ≤ len(ϕ).
3. card(cl+ (ϕ)) ≤ 2 len(ϕ).
Intuitively, the set of execution traces of π is the set exe(π) of sequences of assignments that corresponds to all possible executions of program π. The set exe(ϕ) corresponds to all possible executions of all programs in ϕ. These are defined by a mutual
recursion, as displayed in Table 3. We use the symbol ‘()’ to denote the empty sequence.
The length of execution traces, also given by the function len, is just the number of
atomic programs in it. That is: len(()) = 0, len(α) = 1 and len(σα) = len(σ) + len(α).
The lemma below can also be proved with an easy induction on the length of programs and formulas:
Lemma 2.
1. If π does not contain the Kleene star then len(σ) ≤ len(π), for all σ ∈ exe(π).
2. If ϕ ∈ L−∗ then len(σ) ≤ len(ϕ), for all σ ∈ exe(ϕ).
Note, however, that each σ ∈ exe(π∗ ) is infinite.
3

exe(α) = {α}

exe(p) = {()}
exe(¬ϕ) = exe(ϕ)
exe(ϕ ∧ ψ) = exe(ϕ) ∪ exe(ψ)
exe([π]ϕ) = exe(π) ∪ exe(ϕ)

exe(π1 ; π2 ) = {σ1 σ2 : σ1 ∈ exe(π1 ), σ2 ∈ exe(π2 )}
exe(π1 ∪ π2 ) = exe(π1 ) ∪ exe(π2 )
[
{σ1 . . . σn : σ1 , . . . , σn ∈ exe(π)}
exe(π∗ ) =
n∈N0

exe(ϕ?) = exe(ϕ)
Table 3. Execution traces

2.2 Semantics
A DL-PA model is a set V ⊆ P of propositional variables. When p ∈ V then p is true,
and when p < V then p is false.
The interpretation of an assignment α is in terms of a model update. The update of
a model V by an assignment α is the new model V α such that:
V α = {p : V |= α(p)}
where we suppose that when p is not in the domain of α then α(p) equals p. In particular, for the assignment +p we have V +p = V ∪ {p}. Given a sequence of assignments
α1 . . . αn , for the sake of readability, we sometimes write V α1 ···αn instead of (· · · (V α1 ) · · · )αn .
Formulas ϕ are interpreted as sets of models ||ϕ||, while programs π are interpreted
by means of a (unique) relation between valuations ||π||. Just as in PDL, the formal
definition is by a mutual recursion. It is given in Table 4.

||α|| = {hV, V ′ i : V ′ = V α }

||p|| = {V : p ∈ V}
P

||¬ϕ|| = 2 \ ||ϕ||

||π1 ; π2 || = ||π1 || ◦ ||π2 ||

||ϕ ∧ ψ|| = ||ϕ|| ∩ ||ψ||

||π1 ∪ π2 || = ||π1 || ∪ ||π2 ||
[
(||π||)n
||π∗ || =

||[π]ϕ|| = {V : if hV, V ′ i ∈ ||π|| then V ′ ∈ ||ϕ||}

n∈N0

||ϕ?|| = {hV, Vi : V ∈ ||ϕ||}
Table 4. Interpretation of the DL-PA connectives

As usual, we also write V |= ϕ to mean that V ∈ ||ϕ||. Moreover, given a formula ϕ,
we say that ϕ is DL-PA valid (noted |= ϕ) if and only if ||ϕ|| = 2P , and we say that ϕ is
DL-PA satisfiable if and only if ||ϕ|| , ∅.
For example, the formulas [+p]⊤, [+p]ϕ ↔ ¬[+p]¬ϕ, [π]⊤, [+p]p and [−p]¬p are
all DL-PA valid.
4

2.3 Existing Proof Methods
We now recall the existing methods for both model checking and satisfiability checking in DL-PA. They either use a non-elementary reduction to propositional logic or
a quadratic embedding into PDL. We then provide a linear reduction of satisfiability
checking to model checking. This justifies our focus on a tableaux method for model
checking in the rest of the paper. But first, let us recall some valid principles in DL-PA.
Proposition 1 ([10]). The following principles are valid in DL-PA:
1.
2.
3.
4.
5.
6.
7.
8.

[α]p ↔ α(p)
[ψ?]ϕ ↔ (ψ → ϕ)
[π]¬ϕ ↔ ¬[π]ϕ
[π](ϕ ∧ ψ) ↔ ([π]ϕ ∧ [π]ψ)
[π1 ; π2 ]ϕ ↔ [π1 ][π2 ]ϕ
[π1 ∪ π2 ]ϕ ↔ ([π1 ]ϕ ∧ [π2 ]ϕ)
[π∗ ]ϕ ↔ (ϕ ∧ [π][π∗]ϕ)
From ψ → (ϕ ∧ [π∗ ]ψ) infer ψ → [π∗ ]ϕ

It follows from Proposition 1.1–1.6 plus the rule of substitution of valid equivalences that the star-free fragment of DL-PA is reducible to propositional logic. This
however fails to provide an efficient theorem proving method because the reduced formula might be exponentially longer than the original formula. In [2], it is also shown
that the Kleene star can be eliminated in DL-PA, i.e., there is an algorithm that translates every formula in L to an equivalent formula in L−∗ . Such translation, however,
also leads to much longer formulas. In fact, this is a non-elementary reduction because
it starts from the innermost Kleene star operator.
Satisfiability checking in DL-PA is shown to be in EXPTIME in [2]. The proof is
given via a translation to satisfiability checking in PDL. For every DL-PA formula ϕ, the
translation tr returns a PDL formula which is obtained by just replacing each assignment
±p by an abstract PDL program a±p . To guarantee that the abstract programs behave
the same way as the original assignment, the following set of formulas Γϕ is also used:
Γϕ = {[a+p ]p : p ∈ Pϕ } ∪
{[a−p ]¬p : p ∈ Pϕ } ∪
{ha±p i⊤ : ±p ∈ Pϕ } ∪
{q → [a±p ]q : p, q ∈ Pϕ , p , q} ∪
{¬q → [a±p ]¬q : p, q ∈ Pϕ , p , q}
S
Proposition 2 ([2]). Let Uϕ be the PDL program ( p∈Pϕ (a+p ∪a−p ))∗ . For every DL-PA
formula ϕ, ϕ is DL-PA satisfiable if and only if
^ 
tr(ϕ) ∧ [Uϕ ]
Γϕ
is PDL satisfiable.
5

Note that, even though this reduction is polynomial, a quadratically longer formula
is produced. Precisely, the size of Γϕ is bounded by 5 len(ϕ)2 . Moreover, if we consider
the star-free fragment of DL-PA, this transformation is sub-optimal, because of the
Kleene star operator in Uϕ .5
If follows from the next result that satisfiability checking in DL-PA can be linearly
reduced to model checking in DL-PA.
Proposition 3. Let a formula ϕ ∈ L be given. Let Pϕ = {p1 , . . . , pn }. and let Mϕ be the
DL-PA program (+p1 ∪ −p1 ); . . . ; (+pn ∪ −pn ). Formula ϕ is satisfiable if and only if
V |= hMϕ iϕ for any model V.
Proof. It suffices to see that the interpretation of the program Mϕ relates all possible
valuations in the vocabulary of ϕ, while leaving the other variables unchanged.
⊔
⊓
The operation [Mϕ ] works as a master modality and thus hMϕ i works as its dual.
Because it does not contain the Kleene star operator, the length of hMϕ iϕ is bounded by
3 len(ϕ). Also note that, in particular, ϕ is satisfiable if and only if V = ∅ satisfies hMϕ iϕ.
This means that the input (V, hMϕ iϕ) for the model checking problem is also linear
on the length of ϕ. Therefore, in order to perform satisfiability checking in DL-PA,
one could take advantage of an efficient algorithm for model checking in DL-PA. This
motivates the tableaux methods presented in the next section.
Before concluding this section, let us recall that, in DL-PA, model checking has the
same computational complexity as satisfiability checking. This follows from Proposition 3 above and Proposition 4 below.
Proposition 4 ([2]). For every valuation V and formula ϕ, V ∈ ||ϕ|| if and only if the
formula

 


 ^   ^



¬p
p ∧ 
ϕ ∧ 
p∈Pϕ ∩V

p∈Pϕ \V

is DL-PA satisfiable.

3 A Tableaux Method for Star-Free DL-PA
In this section, we define a model checking procedure for the star-free fragment of
DL-PA using analytic tableaux. We start with some useful definitions.
A labeled formula is a pair λ = hσ, ϕi, where σ = α1 . . . αn is a (possibly empty) sequence of propositional assignments and ϕ ∈ L. A branch is a set of labelled formulas.
Definition 1 (Tableau). Let V ⊆ P and ϕ0 ∈ L−∗ . The initial branch for (V, ϕ0 ) is the
the set b0 = {h(), pi : p ∈ Pϕ0 ∩ V} ∪ {h(), ¬pi : p ∈ Pϕ0 \ V} ∪ {h(), ϕ0 i}. A tableau for
(V, ϕ0 ) is a set of branches T that satisfies one of the following two conditions:
1. T = {b0 }, which is called the initial tableau for (V, ϕ0 ).
5

For the star-free fragment, a transformation without the Kleene star operator is also possible.
S
In this case, the program p∈Pϕ (a+p ∪ a−p ) must be iterated up to len(ϕ), but this leads to an
even longer formula.

6

2. T = (T ′ \ {b}) ∪ B, where T ′ is a tableau for (V, ϕ0 ) containing the branch b and B
is a set of k branches {b ∪ b1 , . . . , b ∪ bk } generated by one of the following tableau
rules below:6
(R¬) hσ, ¬¬ϕi ∈ b implies k = 1 and b1 = {hσ, ϕi}.
(R∧) hσ, ϕ ∧ ψi ∈ b implies k = 1 and b1 = {hσ, ϕi, hσ, ψi}.
(R∨) hσ, ¬(ϕ ∧ ψ)i ∈ b implies k = 2, b1 = {hσ, ¬ϕi} and b2 = {hσ, ¬ψi}.
(R[α]) hσ, [α]ϕi ∈ b implies k = 1 and
b1 = {hσα, ϕi} ∪ {hσα, pi : α(p) = ⊤} ∪ {hσα, ¬pi : α(p) = ⊥}.
(Rhαi) hσ, ¬[α]ϕi ∈ b implies k = 1 and
b1 = {hσα, ¬ϕi} ∪ {hσα, pi : α(p) = ⊤} ∪ {hσα, ¬pi : α(p) = ⊥}.
(R[?]) hσ, [ψ?]ϕi ∈ b implies k = 2, b1 = {hσ, ¬ψi} and b2 = {hσ, ϕi}.
(Rh?i) hσ, ¬[ψ?]ϕi ∈ b implies k = 1 and b1 = {hσ, ψi, hσ, ¬ϕi}.
(R[;]) hσ, [π1 ; π2 ]ϕi ∈ b implies k = 1 and b1 = {hσ, [π1 ][π2 ]ϕi}.
(Rh;i) hσ, ¬[π1 ; π2 ]ϕi ∈ b implies k = 1 and b1 = {hσ, ¬[π1 ][π2 ]ϕi}.
(R[∪]) hσ, [π1 ∪ π2 ]ϕi implies k = 1 and b1 = {hσ, [π1 ]ϕi, hσ, [π2 ]ϕi}.
(Rh∪i) hσ, ¬[π1 ∪π2 ]ϕi ∈ b implies k = 2, b1 = {hσ, ¬[π1 ]ϕi} and b2 = {hσ, ¬[π2 ]ϕi}.
(RP1) {hσ, pi, hσα, ψi} ⊆ b for some ψ and p < dom(α) implies k = 1 and
b1 = {hσα, pi}.
(RP2) {hσ, ¬pi, hσα, ψi} ⊆ b for some ψ and p < dom(α) implies k = 1 and
b1 = {hσα, ¬pi}.
The initial tableau corresponds to the input of the problem in the tableau. Rules
R¬, R∧ and R∨ are the standard tableaux rules for Boolean connectives. RP1 and RP2
(propagation rules) propagate literals whose the truth value is not changed by assignments: if the model updated by σ satisfies p and α does not change the truth value of
p then the model updated by σα also satisfies p. The other rules just reflect the semantic definition of the corresponding programs. For instance, for the rule R[α], if the
model updated by the sequence of assignments σ satisfies [α]ϕ then the model updated
by the sequence σα satisfies ϕ. Note that they also correspond to the validities 1–6 in
Proposition 1.
A branch b is blatantly inconsistent if and only if b contains both hσ, ϕi and hσ, ¬ϕi,
for some σ and ϕ. A branch b is closed if and only if it is blatantly inconsistent. A
tableau is closed if and only if all its branches are closed. A tableau is open if and only
if it is not closed.
The idea is that, if there is a closed tableau for the input (V, ϕ0 ) then V 6|= ϕ0 . On the
other hand, if there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .
Example 1. Table 5 shows how the method can be used to prove that the model V =
{p, q} does not satisfy the formula ϕ0 = ¬[+p∪−p]q. In the table, lines 1–3 consist of the
initial tableau for the input (V, ϕ0 ). Rule applications are indicated between parentheses
on the left of each line. Line 4 is generated by the application of R[∪] to line 3. This
generates two different branches. The rule applications continue until both branches are
closed.
6

Some of these rules are also presented in the more traditional numerator-denominator form in
Table 10 of the Appendix.

7

4.
5.
6.
7.
8.

1. () p
2. () q
3. () ¬[+p ∪ −p]q
()
¬[+p]q (Rh∪i: 3) 4. ()
+p p
(Rhαi: 4) 5. −p
+p ¬q
(Rhαi: 4) 6. −p
+p q
(RP1: 2, 5) 7. +p
(closed) (6, 7)
8.

¬[−p]q
¬p
¬q
q
(closed)

(Rh∪i: 3)
(Rhαi: 4)
(Rhαi: 4)
(RP1: 2, 5)
(6, 7)

Table 5. Tableau for V = {p, q} and ϕ0 = ¬[+p ∪ −p]q

Example 2. Table 6 shows how the method can be used to prove that the model V = ∅
satisfy the formula ϕ0 = [¬p?; +p]p. Note that RP2 is not applicable to the labelled
formulas in lines 1 and 5 because p ∈ dom(+p). Thus, the branch on the right remains
open, which means that V |= ϕ0 .

() ¬p
() [¬p?; +p]p
() [¬p?][+p]p (R[;]: 2)
() ¬¬p
(R[?]: 3) 4. ()
[+p]p
() p
(R¬: 4) 5. +p p
(closed) (1, 5)
(open)
1.
2.
3.

4.
5.

(R[?]: 3)
(R[α]: 4)

Table 6. Tableau for V = ∅ and ϕ0 = [¬p?; +p]p

In the sequel, we show the soundness of the method. The idea is to show that, if
V |= ϕ0 , then successive rule applications can never close the tableau. But first, a useful
definition and a lemma are presented.
Definition 2 (Consistent Branch). A branch b is consistent if and only if V σ |= ϕ for
every hσ, ϕi ∈ b.
Lemma 3 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a
consistent branch.
Theorem 1 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0 ).
We now address the completeness of the method. The idea is to show that, if the
tableau remains open after all possible applications of the tableau rules, then V |= ϕ0 .
But first, some useful definitions are presented.
Definition 3 (Witness). A witness to rule ρ in branch b is a labelled formula hσ, ϕi ∈ b
allowing the application of ρ.
8

For example, h(), ¬¬pi is a witness to R¬, and hβ, ¬[+p, −q]pi is a witness to Rhαi.
Moreover, the formula hσ, pi is a witness to RP1 in b if there is a formula hσα, ψi ∈ b
and p < dom(α).
Definition 4 (Saturated Tableau). The label σ in the branch b is saturated under the
tableau rule ρ if and only if for each witness hσ, ϕi to ρ in b, b contains some bi generated by the application of ρ to b. The branch b is saturated under the tableau rule
ρ if and only if all its labels are saturated. A branch is saturated if and only if it is
saturated under all tableau rules. A tableau is saturated if and only if all its branches
are saturated.
Theorem 2 (Completeness). If there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .

4 An Optimal Procedure for Star-Free DL-PA
In this section we define an algorithm to check whether V |= ϕ0 , for ϕ0 ∈ L−∗ . Such an
algorithm is displayed in Table 7. It implements the tableaux method using the recursive
function mcTableau. It takes as argument a tableau branch b and returns whether b is
consistent. When called with the initial tableau for (V, ϕ0 ) it returns whether V |= ϕ0 .
The execution of mcTableau explores in a depth-first manner a tree whose nodes are
tableau branches and each child is generated by the application of a tableau rule to its
parent.
The rules are applied in a specific order and, after the application of a rule, the
witness is marked ‘non-applicable’, thus avoiding an infinite loop. Lines 8–21 perform
what is called ‘local saturation’. That is, only rules that do not create labelled formulas
with different labels than that of the witness are applied. Its first part (lines 8–11) applies
rules that do not create more than one branch in the tableau. Its second part (lines 12–
21) apples rules that create more than one branch in the tableau. At the end of the
local saturation, only witnesses to rules R[α], Rhαi remain. Note that no new label is
created in the local saturation part, which means that there can be no witnesses to rules
RP1 and RP2. Then, in lines 22–38 the algorithm performs what is called ‘successor
creation’. First (line 22), it tests whether there is a successor to be created, i.e., if there
is a witness λ to R[α] or Rhαi. It creates the successor (line 23) and then marks the
witness as ‘non-applicable’ (line 24). After that (lines 25–34), it propagates the suitable
formulas to the successor, as follows: assume that the witness is λ = hσ, [α]ψi. Then,
for every labelled formula hσ, [α]ψ′ i and hσ, hαiψ′ i there must be a labelled formula
hσα, ψ′ i in the successor. This is done in lines 25–29. And also, every labelled formula
hσ, pi (resp. hσ, ¬pi) must be propagated, i.e., there must be a labelled formula hσα, pi
(resp. hσα, ¬pi) in the successor b1 . This is done in lines 30–34. The last part (lines 35–
37) makes a recursive call to mcTableau with the b1 . The current branch is considered
satisfiable if all recursive calls return true.
This algorithm has two important features. First, its successor creation part guarantees that each time mcTableau is called with branch b as argument, all the labelled
formulas in b have the same label. Second, the first feature implies that the list of successors created during successive recursive calls of mcTableau corresponds to one execution trace from input formula ϕ0 . These are the key arguments used in the proof of
complexity result below.
9

1: input: (V,
 ϕ0 )


true, if b is satisfiable
2: output: 

false, otherwise
3: begin
4:
mcTableau(b0 )
5: end
6: function mcTableau(b)
7: begin
8:
if b contains an applicable witness λ to a rule ρ ∈ {R¬, R∧, Rh?i, R[;], Rh;i, R[∪]} then
9:
b1 ← the branch generated by the application of ρ to b using λ as witness
10:
mark λ as ‘non-applicable’
11:
return mcTableau(b ∪ b1 )
12:
else if b contains an applicable witness λ to a rule ρ ∈ {R∨, R[?], Rh∪i, RC} then
13:
B ← the set of branches {b1 , . . . , bn } generated by the application of ρ to b using λ as witness
14:
mark λ as ‘non-applicable’
15:
for each bi ∈ B do
16:
if mcTableau(b ∪ bi ) = true then
17:
return true
18:
end if
19:
end for
20:
return false
21:
end if
22:
while there is an atomic program α such that b contains an applicable witness
λ = hσ, ϕi to rule ρ ∈ {R[α], Rhαi}, where ϕ = [α]ψ or ϕ = hαiψ do
23:
b1 ← the branch generated by the application of ρ to b using λ as witness
24:
mark λ as ‘non-applicable’
25:
while b contains an applicable witness λ′ = hσ, ϕ′ i to rule ρ ∈ {R[α], Rhαi},
where ϕ′ = [α]ψ′ or ϕ′ = hαiψ′ do
26:
b′1 ← the branch generated by the application of ρ to b using λ′ as witness
27:
mark λ′ as ‘non-applicable’
28:
b1 ← b1 ∪ b′1
29:
end while
30:
while b ∪ b1 contains an applicable witness λ′′ to rule ρ ∈ {RP1 , RP2 } do
31:
b′1 ← the branch generated by the application of ρ to b using λ′′ as witness
32:
mark λ′′ as ‘non-applicable’
33:
b1 ← b1 ∪ b′1
34:
end while
35:
if mcTableau(b1 ) = false then
36:
return false
37:
end if
38:
end while
39:
return true
40: end
Table 7. Algorithm implementing the tableaux method for star-free DL-PA

10

Theorem 3 (Termination). The algorithm in Table 7 halts for every input (V, ϕ0 ).
Theorem 4 (Complexity). The amount of memory used by the algorithm in Table 7 is
a polynomial function of the length of the input (V, ϕ0 ).
Therefore, the algorithm in Table 7 works in space polynomial in the length of the
input. This is an optimal algorithm, given that the satisfiability problem in star-free
DL-PA is PSPACE-complete [10].

5 A Tableaux Method for Full DL-PA
In this section, we define an extension of the tableaux method that also takes into account the Kleene star operator.
Definition 5 (Tableau). Let (V, ϕ0 ) be the input under concern (thus, the initial tableau
is the same as in Definition 1). The tableau rules for full DL-PA are those of Definition 1
plus the following ones:
(R[∗]) hσ, [π∗ ]ϕi ∈ b implies k = 1 and b1 = {hσ, ϕi, hσ, [π][π∗ ]ϕi}.
(Rh∗i) hσ, ¬[π∗ ]ϕi ∈ b implies k = 2, b1 = {hσ, ¬ϕi} and b2 = {hσ, ϕi, hσ, ¬[π][π∗ ]ϕi}.
The two rules above reflect the fix point property of Proposition 1.7. For instance,
if the model V σ |= [π∗ ]ϕ then V σ |= ϕ and also V σ |= [π][π∗ ]ϕ.
Definition 6 (Fulfillment). An eventuality hσ, ¬[π∗ ]ϕi) is fulfilled in a tableau branch
b if and only if there is a (possibly empty) execution trace σ′ ∈ exe(π) such that
hσσ′ , ¬ϕi ∈ b.
Definition 7 (Closed Branch). A branch b is closed if and only if (1) b is blatantly
inconsistent or (2) b is saturated and contains an unfulfilled eventuality.
Example 3. Table 8 shows how the method can be used to prove that model V = {p, q}
does not satisfy the formula ϕ0 = ¬[(+p∪−p)∗ ]q. The leftmost branch is closed because
it is blatantly inconsistent. In the branch of the middle, the same pattern will be repeated
indefinitely. Thus, it is an infinite brunch, but it is saturated. Since the eventuality in line
3 is not fulfilled, it is also closed. The right-most branch is analogous to the one in the
middle.
If the input formula contains a sub-formula of the form ¬[π∗ ]ϕ, the method invariably creates tableaux with infinite branches that repeat the same pattern over and over
again, as in Example 3. The repetition can be detected and it is possible to provide a
terminating algorithm. This is presented in Section 6. Here, we show the correctness of
the method presented so far.
Lemma 4 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a
consistent branch.
Theorem 5 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0 ).
Theorem 6 (Completeness). If there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .
11

1.
2.
3.
4.
5.

()

¬q
(blat. inc.)

(Rh∗i: 3)
(2, 4)

5.
6.
7.
8.

() p
() q
() ¬[(+p ∪ −p)∗ ]q
4. () ¬[+p ∪ −p][(+p ∪ −p)∗ ]q (Rh∗i: 3)
..
.
()
¬[+p][(+p ∪ −p)∗ ]q (Rh∪i: 3)
(closed)
+p p
(Rhαi: 5)
+p ¬[(+p ∪ −p)∗ ]q
(Rhαi: 5)
+p q
(RP1: 2, 6)
..
.
(closed)

Table 8. Tableau for V = {p, q} and ϕ0 = ¬[(+p ∪ −p)∗ ]q

6 An EXPTIME Procedure for Full DL-PA
In this section, we define a procedure to model check formulas in L. As before, we
define an algorithm. Here, it must detect the aforementioned repetitions of the applications of Rh∗i in the tableau. This is done by performing equality tests. A label σ1 is said
to be equal to a label σ2 if and only if the set of formulas labelled by σ1 and σ2 are the
same. More formally we have:
Definition 8 (Equality). Let σ1 and σ2 be two labels in the tableau T . Label σ1 is
equal to label σ2 (noted σ1 = σ2 ) if and only if there are two branches b1 , b2 ∈ T such
that {ϕ : hσ1 , ϕi ∈ b1 } = {ϕ : hσ2 , ϕi ∈ b2 }.
An equality test between labels can prevent the tableau to enter in an infinite loop.
Then one can try to provide an algorithm that is similar to the one in Section 4, by
first adding rules R[∗] and Rh∗i in their suitable places and the equality test just before
the exploration of a new successor. Such an algorithm works, but is not optimal. For
instance, the application of the method to the formula [(+p1 ∪ −p1 ∪ · · · ∪ +pn ∪ −pn )∗ ]p
creates 2n different successors from a single tableau branch. Then such a method may
len(ϕ )
explore a tree whose the number of nodes is bounded by 22 0 . However, satisfiability
in DL-PA is proven to be in EXPTIME.
A different technique than that in Section 4 must be employed in order to obtain a
more efficient method for full DL-PA. Such a technique is implemented in the algorithm
of Table 9. It is somewhat similar to the algorithm in Section 4, but there are some
important differences. The most important ones are the addition of the equality test
in lines 17–19 and the fact that this algorithm now maintains the entire tableau T in
memory. It does not uses a recursive function anymore, for it now uses the tableau T as
the search tree. Once the initial tableau for (V, ϕ0 ) is created in line 4, it enters a loop
that finishes when T is closed or saturated (recall that a branch is also considered to
be closed if it is saturated and contains an unfulfilled eventuality). As before, there is a
‘local saturation’ part (lines 9–16) and a ‘successor creation’ part (lines 20–33). In lines
36–40, the algorithm tests whether T is still open to return the right answer.
12

1: input: (V,
 ϕ0 )


true, if ϕ0 is satisfiable
2: output: 

false, otherwise
3: begin
4:
T ← {b0 }
5:
while T is open and unsaturated do
6:
pick an open and unsaturated branch b ∈ T
7:
while b is open and unsaturated do
8:
pick an open unsaturated label σ of b
9:
if λ = hσ, ϕi ∈ b is an applicable witness to a rule ρ ∈ {R¬, R∧, Rh?i, R[;], Rh;i, R[∪], R[∗]} then
10:
b1 ← the branch generated by the application of ρ to b using λ as witness
11:
mark λ as ‘non-applicable’
12:
T ← (T \ {b}) ∪ {b ∪ b1 }
13:
else if λ = hσ, ϕi ∈ b is an applicable witness to a rule ρ ∈ {R∨, R[?], Rh∪i, Rh∗i, RC} then
14:
{b1 , b2 } ← the branches generated by the application of ρ to b using λ as witness
15:
mark λ as ‘non-applicable’
16:
T ← (T \ {b}) ∪ {b ∪ b1 , b ∪ b2 }
17:
else if there is a label σ′ in T such that σ = σ′ then
18:
mark all formulas in b labelled by σ as ‘non-applicable’
19:
if σ′ is closed then close branch b end if
20:
else if there is an atomic program α such that b contains an applicable witness
λ = hσ, ϕi to rule ρ ∈ {R[α], Rhαi}, where ϕ = [α]ψ or ϕ = hαiψ do
21:
b1 ← the branch generated by the application of ρ to b using λ as witness
22:
mark λ as ‘non-applicable’
23:
while b contains an applicable witness λ′ = hσ, ϕ′ i to rule ρ ∈ {R[α], Rhαi},
where ϕ′ = [α]ψ′ or ϕ′ = hαiψ′ do
24:
b′1 ← the branch generated by the application of ρ to b using λ′ as witness
25:
mark λ′ as ‘non-applicable’
26:
b1 ← b1 ∪ b′1
27:
end while
28:
while b ∪ b1 contains an applicable witness λ′′ to rule ρ ∈ {RP1 , RP2 } do
29:
b′1 ← the branch generated by the application of ρ to b using λ′′ as witness
30:
mark λ′′ as ‘non-applicable’
31:
b1 ← b1 ∪ b′1
32:
end while
33:
T ← (T \ {b}) ∪ {b ∪ b1 }
34:
end if
35:
end while
36:
end while
37:
if T is open then
38:
return true
39:
else
40:
return false
41:
end if
42: end
Table 9. Algorithm implementing the tableaux method for L

13

Theorem 7 (Termination). The algorithm in Table 9 halts for every input (V, ϕ0 ).
Theorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an
exponential function of the length of the input (V, ϕ0 ).
Thus, the algorithm in Table 9 works in time exponential on len(ϕ0 ). This is as
expected, given that the model checking problem in full DL-PA is in EXPTIME [10].

7 Discussion and Conclusion
In this paper, we have defined a linear reduction of satisfiability checking into model
checking in DL-PA. We also define analytic tableaux methods for model checking formulas in the star-free fragment and in full DL-PA. The complexity of these methods
match the complexity class of their respective problems. In the sequel, we compare
such methods to similar approaches and discuss possible improvements and extensions.
Comparisons. The methods presented in this paper have been inspired by others already proposed in the literature. For instance, De Giacomo and Massacci [3] (see also
[12]) inspired the technique for the Kleene star. As already mentioned, the naive strategy would generate tableau branches with size exponential in the length of the input
formula. The idea of keeping the tree in memory and perform equality tests comes from
that work.
Assignments of Propositional Variables to Formulas. DL-PA can be extended with assignments α to formulas in L, instead of the simpler {⊤, ⊥}. The corresponding tableau
rule R[α] would be as follows:
σ : ψ1
σ : ψ2
..
.

σ : [α]ϕ
σ : ¬ψ1
σ : ψ2
..
.

σ : ¬ψ1
σ : ¬ψ2
..
.

σ : ψn
σα : p1
σα : p2
..
.

σα : ψn
σα : ¬p1 . . .
σα : p2
..
.

σ : ¬ψn
σα : ¬p1
σα : ¬p2
..
.

σα : pn σα : pn
σα : ϕ σα : ϕ

σα : ¬pn
σα : ϕ

where we assume that the domain of α is {p1 , . . . , pn } and let α(pi ) = ψi .
In spite of the apparent complexity of this tableau rule, we believe that the complexity of the method is not affected in the star-free fragment. For the full language, we
have to include a cut rule that ranges over all sub-formulas of the input formula ϕ0 . The
reason is to permit the equality test to work also with all formulas ψi that are included
in the tableau when the new rule R[α] is applied. Again, we believe that the complexity
remains the same.
14

Other PDL Connectives. The integration of converse, complement, intersection and
other PDL program connectives is also on our agenda. For instance, we believe that we
can apply techniques similar to the ones in [13,6,1] for the converse. In this case though,
it is not clear whether complexity (or even decidability) results remain the same. This
is subject of future work.

References
1. Pietro Abate, Rajeev Goré, and Florian Widmann. An on-the-fly tableau-based decision
procedure for PDL-satisfiability. Electr. Notes Theor. Comput. Sci., 231:191–209, 2009.
2. Philippe Balbiani, Andreas Herzig, and Nicolas Troquard. Dynamic logic of propositional
assignments: a well-behaved variant of PDL. In Orna Kupferman, editor, Logic in Computer
Science (LICS), New Orleans, June 25-28, 2013, http://www.ieee.org/, juin 2013. IEEE.
3. Giuseppe De Giacomo and Fabio Massacci. Combining deduction and model checking into
tableaux and algorithms for converse-PDL. Information and Computation, 162(1–2):117–
137, 2000.
4. Sylvie Doutre, Andreas Herzig, and Laurent Perrussel. A dynamic logic framework for
abstract argumentation. In Chitta Baral and Giuseppe De Giacomo, editors, Proc. KR 2014.
Morgan Kaufmann, 2014.
5. Michael J. Fischer and Richard E. Ladner. Propositional dynamic logic of regular programs.
J. Comput. Syst. Sci., 18(2):194–211, 1979.
6. Rajeev Goré and Florian Widmann. Optimal and cut-free tableaux for propositional dynamic
logic with converse. In Automated Reasoning, volume 6173 of Lecture Notes in Computer
Science, pages 225–239. Springer, 2010.
7. David Harel. Dynamic logic. In Dov M. Gabbay and Franz Günthner, editors, Handbook of
Philosophical Logic, volume II, pages 497–604. D. Reidel, Dordrecht, 1984.
8. David Harel, Dexter Kozen, and Jerzy Tiuryn. Dynamic Logic. MIT Press, 2000.
9. Andreas Herzig. Belief change operations: a short history of nearly everything, told in dynamic logic of propositional assignments. In Chitta Baral and Giuseppe De Giacomo, editors,
Proc. KR 2014. Morgan Kaufmann, 2014.
10. Andreas Herzig, Emiliano Lorini, Frédéric Moisan, and Nicolas Troquard. A dynamic
logic of normative systems. In Toby Walsh, editor, International Joint Conference on Artificial Intelligence (IJCAI), Barcelona, 2011. Morgan Kaufmann Publishers. erratum at
http://www.irit.fr/˜ Andreas.Herzig/P/Ijcai11.html.
11. Andreas Herzig, Pilar Pozos Parra, and François Schwarzentruber. Belief merging in Dynamic Logic of Propositional Assignments. In Christoph Beierle and Carlo Meghini, editors,
International Symposium on Foundations of Information and Knowledge Systems (FoIKS)
(FolKS), Bordeaux. Springer, 2014.
12. Ullrich Hustadt and Renate A. Schmidt. A comparison of solvers for propositional dynamic
logic. In Renate A. Schmidt, Stephan Schulz, and Boris Konev, editors, PAAR-2010, volume 9 of EPiC Series, pages 63–73. EasyChair, 2012.
13. Linh Anh Nguyen and Andrzej Szałas. An optimal tableau decision procedure for conversepdl. In Proceedings of KSE-09, pages 207–214. IEEE Computer Society, 2009.

15

A

Rules in Numerator-Denominator Form

For the comfort of the reader we present here the tableau rules in the more traditional
numerator-denominator form.

(R[α])

σ : ¬[α]ϕ
σα : p1
..
.
σα : pn
σα : ¬pn+1
..
.
σα : ¬pn+m
σα : ¬ϕ

(Rhαi)

σ : [α]ϕ
σα : p1
..
.
σα : pn
σα : ¬pn+1
..
.
σα : ¬pn+m
σα : ϕ

σ : ¬[ψ?]ϕ
σ:ψ
σ : ¬ϕ

(R[?])

σ : [ψ?]ϕ
σ : ¬ψ σ : ϕ

(R[;])

σ : [π1 ; π2 ]ϕ
σ : [π1 ][π2 ]ϕ

(R[∪])

σ : [π1 ∪ π2 ]ϕ
σ : [π1 ]ϕ
σ : [π2 ]ϕ

(Rh∪i)

σ : ¬[π1 ∪ π2 ]ϕ
σ : ¬[π1 ]ϕ σ : ¬[π2 ]ϕ

σ : [π∗ ]ϕ
σ:ϕ
σ : [π][π∗ ]ϕ

(Rh∗i)

σ : ¬[π∗ ]ϕ
σ : ¬ϕ σ : ¬[π][π∗ ]ϕ

(R[∗])

(Rh?i)

(Rh;i)

σ : ¬[π1 ; π2 ]ϕ
σ : ¬[π1 ][π2 ]ϕ

Table 10. Tableau rules for the operator [ ]. In R[α] and Rhαi, we assume that dom(α) =
{p1 , . . . , pn , pn+1 . . . , pn+m } and also α(p1 ) = · · · = α(pn ) = ⊤, and α(pn+1 ) = · · · = α(pn+m ) = ⊥.

B Proofs
Lemma 3 (Consistency Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a
consistent branch.
Proof. The proofs for the rules R¬, R∧ and R∨ are easy and left to the reader. For rule
R[α], note that, because b is consistent, we have V σ |= [α]ϕ. Then V σα |= ϕ by the truth
condition for [α]. Moreover, by the definition of updates we have:
– V σα |= p for all p ∈ dom(α) such that α(p) = ⊤, and
16

– V σα |= ¬p for all p ∈ dom(α) such that α(p) = ⊥.
For the remaining tableau rules, namely Rhαi, R[;], Rh;i, R[∪], and Rh∪i, RP1 and RP2,
the reasoning is similar and left to the reader.
⊔
⊓
Theorem 1 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0 ).
Proof. Assume that V |= ϕ0 . Then the initial tableau for (V, ϕ0 ) is consistent. It follows
from Lemma 3 that all tableaux for ϕ0 have at least one consistent branch b. Now, towards a contradiction, assume that b is closed. Then b contains both hσ, ψi and hσ, ¬ψi,
for some σ and ψ. However, since b is consistent, V σ |= ψ and V σ |= ¬ψ, which is a
contradiction. Therefore, b is not closed neither is the tableau containing it.
⊔
⊓
Theorem 2 (Completeness). If there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .
Proof. Suppose there is no closed tableau for (V, ϕ0 ). Let b be an open and saturated
branch of a tableau for (V, ϕ0 ). We prove that, for every pair hσ, ψi ∈ b, we have V σ |= ψ.
The proof is done by induction on len(σ) + len(ψ) and, in particular, establishes that
V |= ϕ0 , since h(), ϕ0 i ∈ b.
Induction base: We consider two cases:
– Let σ = () and ψ = p ∈ P. Then V |= p, otherwise b would be closed since b0 ⊆ b.
– Let σ = () and ψ = ¬p. Then V |= ¬p, otherwise b would be closed since b0 ⊆ b.
Induction Hypothesis: For every hσ, ψi ∈ b, if len(σ) + len(ψ) ≤ n, then V σ |= ψ.
Induction step: Let len(σ) + len(ψ) = n + 1. We only give some of all possible cases:
– Let σ = σ1 α and ψ = p ∈ P. We consider two sub-cases:
• Let p < dom(α). We have hσ1 , ¬pi < b, otherwise b would be closed, because
it is saturated under RP2. Then we have hσ1 , pi ∈ b, because the branch is
saturated under RP1 and b0 ⊆ b. By induction hypothesis, we have V σ1 |= p.
Since p < dom(α), we also have V σ1 α |= p.
• Let p ∈ dom(α). We then must have α(p) = ⊤: otherwise b would not only
contain hσ1 α, pi, but also hσ1 α, ¬pi (by the application of rule R[α]) and b
would therefore be closed. Hence, by the definition of updates p ∈ V σ1 α . The
latter means that V σ1 α |= p.
– Let σ = σ1 α and ψ = ¬p. Again, we consider two sub-cases:
• Let p < dom(α). We have hσ1 , pi < b: otherwise, b would be closed, since
it is saturated under RP1. Then we have hσ1 , ¬pi ∈ b, because the branch is
saturated under RP2 and b0 ∈ b. Then p < V σ1 (by the induction hypothesis)
and thus p < V σ1 α . Then V σ1 α |= ¬p.
• Let p ∈ dom(α). Note that we have α(p) = ⊥: otherwise b would be closed,
because it would contain hσ1 α, pi and hσ1 α, ¬pi, since it is saturated under
R[α]. Then p < V σ1 α (by its definition) Then V σ1 α |= ¬p.
– Let ψ = ¬¬ψ1 . If hσ, ¬¬ψ1 i ∈ b then hσ, ψ1 i ∈ b (because b is saturated under R¬).
By Induction Hypothesis we have V σ |= ψ1 . Therefore V σ |= ¬¬ψ1 by the truth
condition for negation.
17

– Let ψ = ψ1 ∧ ψ2 . If hσ, ψ1 ∧ ψ2 i ∈ b then hσ, ψ1 i, hσ, ψ2 i ∈ b (because b is saturated
under R∧). By Induction Hypothesis we have V σ |= ψ1 and V σ |= ψ2 . Therefore
V σ |= ψ1 ∧ ψ2 by the truth condition for conjunction.
– Let ψ = ¬(ψ1 ∧ ψ2 ). If hσ, ¬(ψ1 ∧ ψ2 )i ∈ b then hσ, ¬ψ1 i ∈ b or hσ, ¬ψ2 i ∈ b
(because b is saturated under R∨). By Induction Hypothesis we have V σ |= ¬ψ1 or
V σ |= ¬ψ2 . Therefore V σ |= ¬(ψ1 ∧ ψ2 ) by the truth conditions for negation and
conjunction.
– Let ψ = [α]ψ1 . If hσ, [α]ψ1 i ∈ b then hσα, ψ1 i ∈ b (because b is saturated under R[α]). Then, V σα |= ψ1 (by Induction Hypothesis, because len(σ) + len(α) +
len(ψ1 ) < len(σ)+len([α]ψ1 ) = len(σ)+1+len(α)+len(ψ1 )). Therefore, V σ |= [α]ψ1
(by definition).
– Let ψ = [ψ1 ?]ψ2 . If hσ, [ψ1 ?]ψ2 i ∈ b then, because b is saturated under rule R[?],
we consider two sub-cases. Either (1) hσ, ¬ψ1 i ∈ b or (2) hσ, ψ2 i ∈ b. In both subcases, we have V σ |= ψ1 implies V σ |= ψ2 (by Induction Hypothesis). Therefore,
V σ |= [ψ2 ?]ψ2 (by definition).
– Let ψ = [π1 ; π2 ]ψ1 . If hσ, [π1 ; π2 ]ψ1 i ∈ b then hσ, [π1 ][π2 ]ψ2 i ∈ b (because b is
saturated under rule R[;]). Then it is easy to see that hσσ1 , [π2 ]ψ1 i ∈ b, for all
execution traces σ1 ∈ exe(π1 ) Then V σσ1 |= [π2 ]ψ1 (by Induction Hypothesis, since
len(σ) + len(σ1 ) + 1 + len(π2 ) + len(ψ1 ) = len(σσ1 ) + len([π2 ]ψ1 ) < len(σ) +
len([π1 ; π2 ]ψ1 ) = len(σ) + 1 + len(π1 ) + 1 + len(π2 ) + len(ψ1 )). The latter means that
V σ |= [π1 ; π2 ]ψ1 .
– Let ψ = [π1 ∪π2 ]ψ1 . If hσ, [π1 ∪π2 ]ψ1 i ∈ b then hσ, [π1 ]ψ1 i, hσ, [π2 ]ψ1 i ∈ b (because
b is saturated under rule R[∪]). Then, V σ |= [π1 ]ψ1 and V σ |= [π2 ]ψ1 (by Induction
Hypothesis). Therefore, V σ |= [π1 ∪ π2 ]ψ1 (by definition).
– The cases where ψ = ¬[π]ψ1 are analogous to the last ones.
⊔
⊓
Theorem 3 (Termination). The algorithm in Table 7 halts for every input (V, ϕ0 ).
Proof. It is enough to show that function mcTableau is eventually called with an argument b which is either a closed or a saturated branch. Assume that, during the execution,
branch b is passed as argument to a call of function mcTableau. Assume that b contains
a witness λ to one of the tableau rules. Then the function will be called recursively with
a new branch b1 wherein λ is marked ‘non-applicable’, so it will never be a witness
again. Moreover, b1 differs from b by some additional labelled formulas that are shorter
than λ. Therefore, by an easy induction on the length of labelled formulas, we show
that function mcTableau will eventually generate a branch b1 which is either closed or
saturated. The details are omitted.
⊔
⊓
Theorem 4 (Complexity). The amount of memory used by the algorithm in Table 7
is a polynomial function of the length of the input (V, ϕ0 ).
Proof. Each call of function mcTableau generates a new tableau branch. This branch
remains in memory during the recursive calls and is released once the present call of the
function finishes its execution returning true or false. Therefore, to prove our claim, it is
enough to show that the amount of memory used by each tableau branch is a polynomial
function of len(ϕ0 ) and that the number of successive recursive calls to mcTableau is a
polynomial function of len(ϕ0 ) as well.
18

First, we observe that the initial branch b0 contains only formulas from cl+ (ϕ0 ).
Second, each time mcTableau is called with branch b as argument, all the labelled
formulas in b have the same label. Since the amount of memory used by a branch is
bounded by the number of different labelled formulas it contains, it then follows from
Lemma 1 that the number of different labelled formulas in b is bounded by 2 len(ϕ0 ).
Third, the number of successive recursive calls during the local saturation of the
tableau is bounded by the number of different labelled formulas a successor may contain. This number is 2 len(ϕ0 ), again by Lemma 1. Now, recall that the list of successors
created by the algorithm during successive recursive calls of mcTableau corresponds
to one execution trace from input formula ϕ0 . The length of each execution trace is
bounded by len(ϕ0 ), by Lemma 2. Then the number of successive recursive calls that
create new successors is bounded by len(ϕ0 ). Finally, the total number of successive
recursive calls to mcTableau is bounded by 2 len(ϕ0 )2 .
We then conclude that the amount of memory used by the algorithm is proportional
to 4 len(ϕ0 )3 .
⊔
⊓
Lemma 4 (Satisfiability Preservation). For each tableau rule ρ, if branch b is consistent, then the set of branches B generated by the application of ρ to b contains a
consistent branch.
Proof. For the rules that are already part of in the method for star-free DL-PA the proof
is the same as in the proof of Lemma 3. For the other cases, we have:
– Rule R[∗]: If V σ |= [π∗ ]ϕ then, by Proposition 1, V σ |= ϕ and V σ |= [π][π∗ ]ϕ.
– Rule Rh∗i: If V σ |= ¬[π∗ ]ϕ then V σ 6|= [π∗ ]ϕ, and the latter is the case iff V σ |= ¬ϕ
or V σ |= ¬[π][π∗]ϕ, again due to Proposition 1.
⊔
⊓
Theorem 5 (Soundness). If V |= ϕ0 then there is no closed tableau for (V, ϕ0 ).
Proof. Assume that V |= ϕ0 . Then, the initial tableau for (V, ϕ0 ) is consistent. It follows
from Lemma 4 that all tableaux for (V, ϕ0 ) have at least one consistent branch b. Now,
towards a contradiction, assume that b is closed. Then, either (1) b contains both hσ, ϕi
and hσ, ¬ϕi, for some σ and ϕ; or (2) b is saturated and contains an unfulfilled eventuality hσ, ¬[π∗ ]ϕi. In the first case, (because b is consistent) V σ |= ϕ and V σ |= ¬ϕ, which
is a contradiction. In the second case, (again because b is consistent) V σ |= ¬[π∗ ]ϕ.
Moreover, b contains hσσ′ , ϕi, for all execution traces σ′ ∈ exe(π∗ ), by the saturation
′
of Rh∗i and because the eventuality is not fulfilled. Then, V σσ |= ϕ, for all execution
traces σ′ ∈ exe(π∗ ) (because the branch is consistent). Then, V σ |= [πn ]ϕ, for all n ≥ 0.
The latter implies V σ |= [π∗ ]ϕ, which contradicts the hypothesis. So b is not closed, and
therefore the tableau containing b cannot be closed.
⊔
⊓
Theorem 6 (Completeness). If there is no closed tableau for (V, ϕ0 ) then V |= ϕ0 .
Proof. The proof is essentially the same as for Theorem 2. We only add the induction
step case for the Kleene star operator here:
- Let ψ = [π∗ ]ψ1 . If hσ, [π∗ ]ψ1 i ∈ b then hσσ′ , ψ1 i ∈ b, for all execution traces
′
σ′ ∈ exe(π∗ ) (because b is saturated, in particular, under rule R[∗]). Then, V σσ |= ψ,
′
∗
σ
n
for all execution traces σ ∈ exe(π ) (by Induction Hypothesis), iff V |= [π ]ψ, for
all n ∈ N0 , iff V σ |= [π∗ ]ψ.
19

For the case where ψ = ¬[π∗ ]ψ we use the fact that the branch b is not closed, which
means that the eventuality is fulfilled in b, by definition.
⊔
⊓
Theorem 7 (Termination). The algorithm in Table 9 halts for every input (V, ϕ0 ).
Proof. It is enough to show that the algorithm eventually generates a tableau such that
all its branches are either closed or saturated. The algorithm has two parts: local saturation and successor creation.
First, assume that the latest generated tableau T contains an open and unsaturated
branch b with a witness λ to one of the tableau rules of the local saturation part. Then
the algorithm updates T by marking λ as ‘non-applicable’, so it will never be a witness
again. Moreover, the new branches of the updated tableau T differ from the old ones by
somme additional labelled formulas that are either shorter than λ or (in the case of rules
R[∗] and Rh∗i) that can no longer be witnesses to these rules any more. Therefore, by
an easy induction on the length of labelled formulas, we show that the algorithm will
eventually generate a tableau such that all its branches are either closed or saturated for
these rules. The details are omitted.
Second, assume that the latest generated tableau T contains an open and unsaturated
branch b with a witness λ to one of the tableau rules R[α] and Rhαi. Then it marks λ
as ‘non-applicable’ and the updated T contains new branches with somme additional
labelled formulas hσ, ψi, where σ is a new label and ψ ∈ cl+ (ϕ0 ). Since cl+ (ϕ0 ) is finite,
there cannot be an infinite number of different labelled formulas whose labels different
from another label of the tableau. Thus, the equality test will eventually succeeds and
new successors won’t be created indefinitely.
⊔
⊓
Theorem 8 (Complexity). The amount of time used by the algorithm in Table 9 is an
exponential function of the length of the input (V, ϕ0 ).
Proof. The amount of time used by the algorithm in Table 9 is bounded by the number
of rule applications during the execution and the time spent on the equality tests.
First, for each successor, the local saturation part performs at most 2 len(ϕ0 ) rule
applications, because it is the maximum size of cl+ (ϕ0 ) (by Lemma 1). Second, there
can be at most 22 len(ϕ0 ) different labels in the entire tableau T , because it is the maximum size of P(cl+ (ϕ0 )). Then the successor creation part can generate at most 22 len(ϕ0 )
different labels until the equality test succeeds. Moreover, the equality test itself takes
time proportional to 22 len(ϕ0 ) , by the same reasons.
Overall, the amount of time used by the algorithm is bounded by 2 len(ϕ0 )×22 len(ϕ0 ) ×
2 len(ϕ0 )
2
equals to 24 len(ϕ0 )+1 len(ϕ0 ), which is an exponential function of the length of
the input formula ϕ0 .
⊔
⊓

20

