Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

chordal graphs [1,13]. A commonly employed practical technique is therefore
to preprocess the input before trying to compute the pathwidth, by employing
a set of (reversible) data reduction rules. Similar preprocessing techniques for
the Treewidth problem have been studied in detail [7,17], and their practical use has been verified in experiments [8]. Using the concept of kernelization we may analyze the quality of such preprocessing procedures within
the framework of parameterized complexity. A parameterized problem is a language Q ⊆ Σ ∗ × N, and such a problem is (strongly uniform) fixed-parameter
tractable (FPT) if there is an algorithm that decides membership of an instance (x, k) in time f (k)|x|O(1) for some computable function f . A kernelization
(or kernel ) for Q is a polynomial-time algorithm that transforms each input (x, k)
into an equivalent instance (x0 , k 0 ) such that |x0 |, k 0 ≤ g(k) for some computable
function g, which is the size of the kernel. Kernels of polynomial size are of
particular interest due to their practical applications. To analyze the quality
of preprocessing rules for Pathwidth we therefore study whether they yield
polynomial kernels for suitable parameterizations of the Pathwidth problem.
As the pathwidth of a graph equals the maximum of the pathwidth of its
connected components, the Pathwidth problem with standard parameterization is AND-compositional and thus has no polynomial kernel unless the ANDdistillation conjecture does not hold [4]. We thus do not expect to have kernels
for Pathwidth of size polynomial in the target value for pathwidth k, and
we consider whether polynomial kernels can be obtained with respect to other
parameterizations.
As Pathwidth is known to be polynomial-time solvable when restricted
graph classes such as interval graphs [3], trees [11] and cographs [9], it seems
reasonable to think that determining the pathwidth of a graph G which is “almost” an interval graph should also be polynomial-time solvable. Formalizing the
notion of “almost” as the number of vertices that have to be deleted to obtain
a graph in the restricted class F, we can study the extent to which data reduction is possible for graphs which are close to polynomial-time solvable instances
through the following problem:
Pathwidth parameterized by a modulator to F
Instance: A graph G = (V, E), a positive integer k, and a set S ⊆ V
such that G − S ∈ F.
Parameter: ` := |S|.
Question: pw(G) ≤ k?
The set S is a modulator to the class F. Observe that pathwidth should be
polynomial-time solvable on F in order for this parameterized problem to be
FPT. Our main result is a kernel lower bound for such a parameterization of
Pathwidth. We prove that despite the fact that the pathwidth of an interval graph is simply the size of its largest clique minus one — which is very
easy to find on interval graphs — the Pathwidth problem parameterized by
a modulator to an interval graph does not admit a polynomial kernel unless
NP ⊆ coNP/poly. In fact, we prove the stronger statement that, under the same
condition, Pathwidth parameterized by a modulator to a single clique (i.e., by

Kernel Bounds for Structural Parameterizations of Pathwidth

3

distance to F consisting of all complete graphs) does not admit a polynomial
kernel1 (Section 5). As the graph resulting from the lower-bound construction is
co-bipartite, its pathwidth and treewidth coincide [14]: a corollary to our theorem therefore shows that Treewidth parameterized by vertex-deletion distance
to a clique does not admit a polynomial kernel unless NP ⊆ coNP/poly, thereby
significantly strengthening a result of our earlier work [7] where we only managed
to prove kernel lower bounds by modulators from cluster graphs and co-cluster
graphs.
Our kernel bound effectively shows that even in graphs which are cliques after
the deletion of k vertices, the information contained in the (non)edges between
these k vertices and the clique is such that we cannot decrease the size of the
clique to polynomial in k in polynomial time, without changing the answer in
some cases.
Faced with these negative results, we try to formulate safe reduction rules
for Pathwidth (Section 3). It turns out that many of the rules for Treewidth
(e.g., the rules involving (almost) simplicial vertices) are invalid when applied
to Pathwidth, and more careful reduction procedures are needed to reduce
the number of such vertices. We obtain several reduction rules for pathwidth,
and show that they lead to provable data reduction guarantees when analyzed
using a suitable parameterization (Section 4). In particular we prove that Pathwidth parameterized by a vertex cover S (i.e., using F as the class of edgeless
graphs in the template above) admits a kernel with O(|S|3 ) vertices, that the
parameterization by a modulator S 0 to a disjoint union of stars has a kernel
with O(|S 0 |4 ) vertices, and finally that parameterizing by a set S 00 whose deletion leaves a graph in which every connected component has at most c vertices
admits a kernel with O(c · |S 00 |3 + c2 · |S 00 |2 ) vertices.

2

Preliminaries

In this work all graphs are finite, simple, and undirected. The open neighborhood
of a vertex v ∈ V in a graph G is denoted by NG (v), and
S its closed neighborhood
is NG [v]. For sets of vertices W ⊆ V we let NG [W ] = v∈W NG [v] and NG (W ) =
NG [W ]\W . If S ⊆ V is a vertex set then G−S denotes the graph obtained from G
by deleting all vertices of S and their incident edges. For a single vertex v we
write G − v instead of G − {v}. A vertex v is simplicial in a graph G if NG (v) is a
clique. A vertex v ∈ V is almost simplicial in a graph G if v has a neighbor w such
that NG (v)\{w} is a clique. In such a case, we call w the special neighbor of v. For
a set of vertices W ⊆ V , the subgraph of G induced by W is denoted as G[W ]. A
path decomposition of a graph G = (V, E) is a non-empty sequence (X1 , . . . , Xr )
of subsets of V called bags, such that:
1

For completeness we point out that Pathwidth parameterized by a modulator to
a clique is FPT: try all orderings in which the vertices from S can be introduced
and forgotten in a decomposition, and do a polynomial-time computation for each
ordering to find the best way to fit the clique G − X into the decomposition.

4

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

S
– 1≤i≤r Xi = V ,
– for all edges {v, w} ∈ E there is a bag Xi containing v and w, and
– for all vertices v ∈ V , the bags containing v are consecutive in the sequence.
The width of a path decomposition is max1≤i≤r |Xi | − 1. The pathwidth pw(G)
of G is the minimum width of a path decomposition of G. Throughout the paper
we will often make use of the fact that the pathwidth of a graph does not increase
when taking a minor. We also use the following results.
Lemma 1 (Cf. [9]). If graph G contains a clique W then any path- or tree
decomposition for G has a bag containing all vertices of W .
Lemma 2. All graphs G admit a minimum-width path decomposition in which
each simplicial vertex is contained in exactly one bag of the decomposition.
Proof. Lemma 1 shows that for each simplicial vertex v, any path decomposition
of G has a bag containing the clique N [v]. As removal of v from all other bags
preserves the validity of the decomposition, we may do so successively for all
simplicial vertices to obtain a decomposition of the desired form.
t
u

3

Reduction Rules

In this section we give a collection of reduction rules. Formally, each rule takes as
input an instance (G, S, k) of Pathwidth parameterized by a modulator
to F, and outputs an instance (G0 , S 0 , k 0 ). With the exception of occasionally
outright deciding yes or no, none of our reduction rules change the modulator S
or the value of k. In the interest of readability we shall therefore be less formal in
our exposition, and make no mention of the values of S 0 and k 0 in the remainder;
they will be understood to be equal to S and k.
We say that a rule is safe for pathwidth (or in short: safe) if for each input
(G, S, k) and output (G0 , S 0 , k 0 ), the pathwidth of G is at most k if and only if the
pathwidth of G0 is at most k 0 . Any subset of the rules gives a ‘safe’ preprocessing
algorithm for pathwidth: apply the rules until no longer possible. We will argue
later that this takes polynomial time for our rules, and give kernel bounds for
some parameters of the graphs.
3.1

Vertices of small degree

We start off with a few simple rules for vertices of small degree. Note that,
necessarily, these rules are slightly more restrictive than for the treewidth case;
e.g., we cannot simply delete vertices of degree one since trees have treewidth
one but unbounded pathwidth. The first rule is trivial.
Rule 1 Delete any vertex of degree zero.
Rule 2 If two degree-one vertices share their neighbor then delete one of them.

Kernel Bounds for Structural Parameterizations of Pathwidth

5

Correctness of Rule 2 follows from insights on the pathwidth of trees, pioneered by Ellis et al. [11]. A self-contained proof is provided in the appendix.
The following rule handles certain vertices of degree two; a correctness proof
is given in the appendix.
Rule 3 Let v, w be two vertices of degree two, and suppose x and y are common
neighbors to v and w with x ∈ S. Then remove w and add the edge {x, y}.
The differences with safe rules for treewidth are interesting to note: for treewidth,
we can remove vertices of degree one, and remove vertices of degree two when
adding an edge between their neighbors.
3.2

Common neighbors and disjoint paths

Rule 4 in this section also appears in our work on kernelization for treewidth [7]
and traces back to well-known facts about treewidth (e.g.,[2,10]). It is also safe
in the context of pathwidth; the safeness proof is identical to when dealing with
treewidth and is hence deferred to the appendix.
Lemma 3. Let v and w be nonadjacent vertices. Suppose there are at least k + 1
internally vertex disjoint paths from v to w in (V, E). Then the pathwidth of G
is at most k, if and only if the pathwidth of G0 = (V, E ∪ {{v, w}}) is at most k.
A special case of Lemma 3, and the implied Rule 4, is when v and w have
at least k + 1 common neighbors. As we do not want to increase the size of a
modulator, we only add edges between pairs of vertices with at least one endpoint
in the modulator; thus G − S remains unchanged.
Rule 4 (Disjoint paths (with a modulator)) Let v ∈ S be nonadjacent to
w ∈ V , and suppose there are at least k + 1 paths from v to w that only intersect
at v and w, where k denotes the target pathwidth. Then add the edge {v, w}.
3.3

Simplicial vertices

In this section, we give a safe rule that helps to bound the number of simplicial
vertices of degree at least two in a graph. Recall that we already have rules for
vertices of degree one and zero, which are trivially simplicial.
Lemma 4. Let G = (V, E) be a graph, and let v ∈ V be a simplicial vertex
of degree at least two. If for all x, y ∈ NG (v) with x 6= y there is a simplicial
vertex w 6∈ NG [v] such that x, y ∈ NG (w), then pw(G) = pw(G − v).
Proof. As G − v is a subgraph of G, we directly have that pw(G − v) ≤ pw(G).
For the converse, let (X1 , . . . , Xr ) be an optimal path decomposition of G − v.
Using Lemma 2, we assume that for each simplicial vertex x, there is a unique
bag Xix with NG [x] ⊆ Xix .
Let C = NG (v). A bag that contains C is called a C-bag. As C is a clique,
Lemma 1 shows there is at least one C-bag. The C-bags must be consecutive

6

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch
v

Fig. 1. An example of an application of the Simplicial vertex rule.

in the path decomposition; let them be Xi1 , . . . , Xi2 . We will first show there is
a vertex w 6∈ NG [v] which is simplicial in G − v, and is contained in a C-bag.
Let x, y ∈ C (possibly with x = y) be vertices such that x does not occur in bags
with index smaller than i1 , and y does not occur in bags of index larger than i2 .
If x 6= y then let w 6∈ NG [v] be simplicial in G such that x, y ∈ NG (w), whose
existence is guaranteed by the preconditions. As w is also simplicial in G − v it
occurs in a unique bag, which must be a C-bag since it must meet its neighbors x
and y there. If x = y then, as v has degree at least two, there is a vertex w 6∈
NG [v] which is simplicial in G and adjacent to x; hence its unique occurrence is
also in a C-bag.
Thus we have established there is a vertex w 6∈ NG [v] which is simplicial
in G − v and is contained in exactly one bag, which is a C-bag Xi . Now insert
a new bag just after Xi , with vertex set (Xi \ {w}) ∪ {v}. As Xi \ {w} contains
all v’s neighbors, this gives a path decomposition of G without increasing the
width, and concludes the proof.
t
u
Lemma 4 directly shows that Rule 5 is safe for Pathwidth.
Rule 5 Let v be a simplicial vertex of degree at least two. If for all x, y ∈ NG (v)
with x 6= y there is a simplicial vertex w 6∈ NG [v] such that x, y ∈ NG (w), then
remove v.
3.4

Simplicial components

Let S be the set of vertices used as the modulator. We say that a set of vertices W
is a simplicial component if W is a connected component in G−S and NG (W )∩S
is a clique. Our next rule deals with simplicial components.
Rule 6 (Simplicial components of known pathwidth) Let S ⊆ V be the
modulator and let k denote the target pathwidth. Suppose that for each pair v, w ∈
S∩NG (W ) (including v = w), there are at least 2k+3 simplicial components Z 6=
W such that {v, w} ⊆ NG (Z) and pw(G[Z]) ≥ pw(G[W ]). Then remove W and
its incident edges.

Kernel Bounds for Structural Parameterizations of Pathwidth

7

Fig. 2. The vertices marked with a square box form a simplicial component when
interpreting the round vertices as the modulator.

Note that we have to include the case v = w to ensure correctness for simplicial
components which are adjacent to exactly one vertex in the modulator. Lemma 9
in the appendix shows that Rule 6 is safe.
Let us briefly discuss the running time of this reduction rule. As the modulator ensures that G − S is contained in the graph class F, the rule can be
applied in polynomial time if the pathwidth of graphs in F can be determined
efficiently. In the setting in which we apply the rule, the graphs in F are either
disjoint unions of stars (which are restricted types of forests, allowing the use of
the linear-time algorithm of Ellis et al. [11]), or F has constant pathwidth which
means that the FPT algorithm for k-Pathwidth [2] runs in linear time.
3.5

Almost simplicial vertices

For almost simplicial vertices, we have a rule that replaces an almost simplicial
vertex by a number of vertices of degree two. In several practical settings, the
increase of number of vertices may be undesirable; the rule is useful to derive
some theoretical bounds.
v
vw,y

w

vw,x vw,z vx,y vy,z

w

y

y
z

z
x

vx,z

x

Fig. 3. An example of an application of the rule for almost simplicial vertices.

Lemma 5. Let G = (V, E) be a graph and let v ∈ V be an almost simplicial
vertex of degree at least three, with special neighbor w. Let G0 be obtained by
deleting v and by adding a vertex vp,q with neighbors p and q for any p, q ∈ NG (v)
with p 6= q. Then pw(G) = pw(G0 ).

8

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

The proof of the lemma is moved to the appendix. The lemma justifies
the following reduction rule, by observing that an almost simplicial vertex v
with degG (v) > k + 1 means that pw(G) > k, as NG [v] − w then forms a clique
of size at least k + 2.
Rule 7 Let v ∈ V \ S be an almost simplicial vertex of degree at least three
with special neighbor w. Let k be the target pathwidth. If degG (v) > k + 1 then
output no. Otherwise, delete v and add a vertex vp,q with neighbors p and q for
any p, q ∈ N (v) with p 6= q.
As a simplicial vertex is trivially almost simplicial, note that — in comparison
to Rule 5 — the previous rule gives an alternative way of dealing with simplicial
vertices.

4

Polynomial kernelizations

For each of the safe rules given in the previous section, there is a polynomial
time algorithm that tests if the rule can be applied, and if so, modifies the
graph accordingly. (We assume that for Rule 6 the bound ` on the pathwidth of
the components is a constant.) The following lemma shows that any algorithm
that exhaustively applies (possibly just a subset of) these reduction rules can be
implemented to run in polynomial time.
Lemma 6. Each input instance (G, S, k) is exhaustively reduced by O(n2 + nk 2 )
applications of the reduction rules.
Proof. First we note that for non-trivial instances, Rule 4 does not add edges
to a vertex of degree at most two. In particular, no rule increases the number
of vertices of degree at least three. So, we have at most n applications of a rule
that removes a vertex of degree at least three, and O(n2 ) applications of Rule
4. Rule 7 is therefore executed at most n times in total, and thus the number of
vertices of degree two that are added in these steps is bounded by O(nk 2 ). As
each other rule removes at least one vertex, the total number of rule applications
in G is bounded by O(n2 + nk 2 ).
t
u
By analyzing our reduction rules with respect to different structural parameters, we get the following results.
Theorem 1. Pathwidth parameterized by a modulator to F admits
polynomial kernels for the following choices of F:
1. A kernel with O(`3 ) vertices when F is the class of all independent sets, i.e.,
if the modulator S is a vertex cover.
2. A kernel with O(c · `3 + c2 · `2 ) vertices when F is the class of all graphs with
connected components of size at most c.
3. A kernel with O(`4 ) vertices when F is the class of all disjoint unions of
stars.

Kernel Bounds for Structural Parameterizations of Pathwidth

9

Proof. We show Part 3 followed by Part 2. Part 1 follows from the latter since
it is a special case corresponding to c = 1.
(Part 3.) As stars have pathwidth one, graphs with a modulator S of size
` to a set of stars have pathwidth at most ` + 1. Thus, if k ≥ ` + 1, we return a
dummy yes-instance of constant size. Now, assume k ≤ `.
Our kernelization applies Rules 1–6 while possible, and applies Rule 7 to all
vertices which have at most one neighbor in G−S. (Applying the rule to vertices
with more neighbors in G − S might cause the resulting graph G0 − S not to be
a disjoint union of stars.) Recall for Rule 6 that pw(G − S) ≤ 1.
Let (G, S, k) be a reduced instance. We will first bound the number of connected components of G−S, with separate arguments for simplicial and nonsimplicial components. Each component is a star, i.e., it is a single vertex or a K1,r
for some r (a center vertex with r leaves). Note that in this proof the term leaf
refers to a leaf of a star in G − S, independent of its degree in G (and all degrees
mentioned are with respect to G).
Associate each nonsimplicial component C of G − S to an arbitrary pair of
nonadjacent neighbors of C in S. It is easy to see that each such component
provides a path between the two chosen neighbors, and that for different components these paths are internally vertex disjoint. Thus, since Rule 4 does not
apply, no pair of vertices of S has more than k components associated to it.
Hence there are at most k · |S|2 = O(`3 ) nonsimplicial components.
Now consider a simplicial component W of G−S, and note that pw(G[W ]) ≤
1. As Rule 6 does not apply, there is a pair v, w ∈ S ∩ NG (W ) (possibly v =
w) such that there are strictly less than 2k + 3 simplicial components W 0 6=
W with pw(G[W 0 ]) ≥ pw(G[W ]) and {v, w} ⊆ NG (W 0 ). Associate W to the
pair v, w. It follows immediately that no pair of vertices of S has more than 2k+3
components associated to it, which gives a bound of (2k + 3) · |S|2 = O(`3 ) on
the number of simplicial components.
Thus we find that G − S has a total of O(`3 ) connected components (each of
which is a star). This bounds the number of centers of stars by O(`3 ). It remains
to bound the total number of leaves that are adjacent to those centers.
Clearly, each star center has at most one leaf which has degree one (in G) by
Rule 2. Each leaf of degree two has exactly one neighbor in S in addition to its
adjacent star center. Since Rule 3 does not apply, no two leaves of degree two
can have the same star center and neighbor in S; thus there are at most O(`4 )
leaves of degree two.
Now, we are going to count the number of leaves (of stars) that are of degree
more than two. For each such leaf, one neighbor is the center of its star and all
other neighbors are in S. If its neighbors in S would form a clique, then the leaf
would be almost simplicial in G (with the star center as the special neighbor)
and Rule 7 would apply. Hence, as G is reduced, we can associate each such
leaf to a nonadjacent pair of vertices in S. As Rule 4 cannot be applied, we
associate O(k) vertices to a pair, and thus the number of such leaves is bounded
by O(k · `2 ) = O(`3 ).

10

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

Thus, the total number of vertices in G is bounded by O(`4 ). By Lemma 6
the reduction rules can exhaustively be applied in polynomial time. As the rules
preserve the fact that G − S is a disjoint union of stars, the resulting instance
is a correct output for a kernelization algorithm. This completes the proof of
Part 3.
(Part 2.) Fix some constant c and let F be the class of all graphs of component size at most c. Let (G, S, k) be an input instance. Note that the pathwidth
of G is bounded by c + |S| − 1, since each component of G − S has pathwidth at
most c − 1. We assume that k ≤ c + |S| − 2; otherwise the instance is yes and
we may return a dummy yes-instance of constant size.
Our algorithm uses Rules 1, 2, 4, 5, and 6. Regarding Rule 6 we note that the
pathwidth of components of G−S can be computed in constant time (depending
only on c).
Consider a graph G where none of these rules can be applied. The bounds for
the number of simplicial and nonsimplicial components of G−S work analogously
to Part 3; there are O(k|S|2 ) components of the respective types. This gives a
total of O(|S| + c · (c + |S|) · |S|2 ) = O(c2 |S|2 + c|S|3 ) vertices in G, using
that k ≤ c + |S| − 2. This completes the proof of Part 2.
t
u
We remark that while Rule 5 is not needed to establish the kernel bounds
presented in the previous theorem, we have included it in our presentation for
two reasons. First of all, applying the rule may prove to be useful in practical
situations. It also leads to improved theoretical bounds on some quantities. For
example, when F is the class of all independent sets (and the modulator S is a
vertex cover), the use of Rule 5 will decrease the number of simplicial vertices
in G − S to O(|S|2 ), whereas the bound would be O(|S|3 ) without this rule.
Alas, as the kernel size for this choice of F is dominated by the Θ(|S|3 ) term for
the number of non-simplicial vertices, we still end up with a cubic-vertex kernel.

5

Lower bounds: Modulator to a Single Clique

We complement the positive results of the previous section by some negative
results. In particular, we show that the problems Treewidth parameterized
by a modulator to a single clique (TWMSC) and Pathwidth parameterized by a modulator to a single clique (PWMSC) do not admit a
polynomial kernel unless NP ⊆ coNP/poly. In fact, we show that the results
hold when restricted to co-bipartite graphs; as for these graphs the pathwidth
equals the treewidth [14], the same proof works for both problems. The problems
are covered by the general template given in the introduction, when using F as
the class of all cliques. Observe that F only contains connected graphs, and in
particular F is not closed under disjoint union.
To prove the lower bound we employ the technique of cross-composition
[6], starting from the following NP-complete version [15, Corollary 2.10] of the
Cutwidth problem:

Kernel Bounds for Structural Parameterizations of Pathwidth

11

Cutwidth on cubic graphs (Cutwidth3)
Instance: A graph G on n vertices in which each vertex has degree at
least one and at most three, and an integer k ≤ |E(G)|.
Question: Is there a linear layout of G of cutwidth at most k, i.e., a
permutation π of V (G) such that maxni=1 |{{u, v} ∈ E(G) | π(u) ≤ i <
π(v)}| ≤ k?
As space restrictions prohibit us from presenting the full proof in this extended abstract, we will sketch the main ideas. To obtain a kernel lower bound
through cross-composition, we have to embed the logical OR of a series of t
input instances of Cutwidth3 on n vertices each into a single instance of the
target problem for a parameter value polynomial in n + log t. At the heart of our
construction lies an idea of Arnborg et al. [1] employed in their NP-completeness
proof for Treewidth. They interpreted the treewidth of a graph as the minimum cost of an elimination ordering on its vertices2 , and showed how for a given
graph G a co-bipartite graph G∗ can be created such that the cost of elimination
orderings on G∗ corresponds to the cutwidth of G under a related ordering.
We extend their construction significantly. By the degree bound, instances
with n vertices have O(n2 ) different degree sequences. The framework of crosscomposition thus allows us to work on instances with the same degree sequence
(and same k). By enforcing that the structure of one side of the co-bipartite
graph G∗ only has to depend on this sequence, all inputs can share the same
“right hand side” of the co-bipartite graph; this part will remain small and act as
the modulator. By a careful balancing act of weight values we then ensure that
the cost of elimination orderings on the constructed graph G∗ are dominated by
eliminating the vertices corresponding to exactly one of the input instances, ensuring that a sufficiently low treewidth is already achieved when one of the input
instances is yes. On the other hand, the use of a binary-encoding representation
of instance numbers ensures that low-cost elimination orderings for G∗ do not
mix vertices corresponding to different input instances. The remaining details
can be found in Appendix D. Our construction yields the following results.
Theorem 2. Unless NP ⊆ coNP/poly, Pathwidth and Treewidth do not
admit polynomial kernels when parameterized by a modulator to a single clique.
Interestingly, the parameter at hand is nothing else than the size of a vertex
cover in the complement graph.

6

Conclusions

In this paper, we investigated the existence of polynomial kernelizations for
Pathwidth. Taking into account that the problem is already known to be ANDcompositional with respect to the target pathwidth — thus excluding polynomial
2

To eliminate a vertex in a graph means to remove it while completing its open
neighborhood into a clique. When eliminating the vertices of a graph in the order
given by π, the cost of the elimination ordering π is the maximum degree of a vertex
at the time it is eliminated.

12

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

kernels under the AND-distillation conjecture — we study alternative, structural
parameterizations.
Our main result is that Pathwidth admits no polynomial kernelization with
respect to the number of vertex deletions necessary to obtain a clique, unless
NP ⊆ coNP/poly. This rules out polynomial kernels for vertex deletion distance
from various interesting graph classes on which Pathwidth is known to be
polynomial-time solvable, like chordal and interval graphs.
On the positive side we develop a collection of safe reduction rules for Pathwidth. Analyzing the effect of the rules we show that they give polynomial kernels with respect to the following parameters: vertex cover (i.e., distance from
the class of independent sets), distance from graphs of bounded component size,
and distance from disjoint union of stars.
It is an interesting open problem to determine whether there is a polynomial
kernel for Pathwidth parameterized by the size of a feedback vertex set. For the
related Treewidth problem, a kernel with O(|S|4 ) vertices is known [7], where S
denotes a feedback vertex set. Regarding Pathwidth, long paths in G − S are
the main obstacle that needs to be addressed by additional reduction rules.

References
1. S. Arnborg, D. G. Corneil, and A. Proskurowski. Complexity of finding embeddings
in a k-tree. SIAM Journal on Algebraic and Discrete Methods, 8:277–284, 1987.
doi:10.1137/0608024.
2. H. L. Bodlaender. A linear-time algorithm for finding tree-decompositions of
small treewidth. SIAM J. Comput., 25(6):1305–1317, 1996. doi:10.1145/167088.
167161.
3. H. L. Bodlaender. A partial k-arboretum of graphs with bounded treewidth. Theor.
Comput. Sci., 209(1-2):1–45, 1998. doi:10.1016/S0304-3975(97)00228-4.
4. H. L. Bodlaender, R. G. Downey, M. R. Fellows, and D. Hermelin. On problems
without polynomial kernels. J. Comput. Syst. Sci., 75(8):423–434, 2009. doi:
10.1016/j.jcss.2009.04.001.
5. H. L. Bodlaender, F. V. Fomin, A. M. C. A. Koster, D. Kratsch, and D. M. Thilikos. A note on exact algorithms for vertex ordering problems on graphs. Theory
Comput. Syst., 50(3):420–432, 2012. doi:10.1007/s00224-011-9312-0.
6. H. L. Bodlaender, B. M. P. Jansen, and S. Kratsch. Cross-composition: A new
technique for kernelization lower bounds. In Proc. 28th STACS, pages 165–176,
2011. doi:10.4230/LIPIcs.STACS.2011.165.
7. H. L. Bodlaender, B. M. P. Jansen, and S. Kratsch. Preprocessing for treewidth: A
combinatorial analysis through kernelization. In Proc. 38th ICALP, pages 437–448,
2011. doi:10.1007/978-3-642-22006-7_37.
8. H. L. Bodlaender, A. M. C. A. Koster, and F. van den Eijkhof. Preprocessing rules
for triangulation of probabilistic networks. Computational Intelligence, 21(3):286–
305, 2005. doi:10.1111/j.1467-8640.2005.00274.x.
9. H. L. Bodlaender and R. H. Möhring. The pathwidth and treewidth of cographs.
SIAM J. Discrete Math., 6:181–188, 1993. doi:10.1137/0406014.
10. F. Clautiaux, J. Carlier, A. Moukrim, and S. Négre. New lower and upper
bounds for graph treewidth. In Proc. 2nd WEA, pages 70–80, 2003. doi:
10.1007/3-540-44867-5_6.

Kernel Bounds for Structural Parameterizations of Pathwidth

13

11. J. A. Ellis, I. H. Sudborough, and J. S. Turner. The vertex separation and search
number of a graph. Inf. Comput., 113(1):50–79, 1994. doi:10.1006/inco.1994.
1064.
12. J. Guo and R. Niedermeier. Invitation to data reduction and problem kernelization.
SIGACT News, 38(1):31–45, 2007. doi:10.1145/1233481.1233493.
13. J. Gustedt. On the pathwidth of chordal graphs. Discrete Appl. Math., 45(3):233–
248, 1993. doi:10.1016/0166-218X(93)90012-D.
14. R. H. Möhring. Triangulating graphs without asteroidal triples. Discrete Applied
Mathematics, 64(3):281–287, 1996. doi:10.1016/0166-218X(95)00095-9.
15. B. Monien and I. H. Sudborough. Min cut is NP-complete for edge weighted treees.
Theor. Comput. Sci., 58:209–229, 1988. doi:10.1016/0304-3975(88)90028-X.
16. N. Robertson and P. D. Seymour. Graph minors. I. Excluding a forest. J. Comb.
Theory, Ser. B, 35:39–61, 1983. doi:10.1016/0095-8956(83)90079-5.
17. F. van den Eijkhof, H. L. Bodlaender, and A. M. C. A. Koster. Safe reduction
rules for weighted treewidth. Algorithmica, 47(2):139–158, 2007. doi:10.1007/
s00453-006-1226-x.

14

A

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

Safeness of low degree rules

Lemma 7. Rule 2 is safe.
Proof. Let u and v be two vertices of degree one with shared neighbor w and
let G0 be obtained from G by removing v.
By Lemma 2 there is a minimum-width path decomposition (X1 , . . . , Xr )
of G0 in which u occurs in a unique bag Xi , which must therefore also contain w.
We obtain a path decomposition for G0 by adding a bag Xi0 containing (Xi \
{u}) ∪ {v} next to bag Xi . As this does not increase the width, safeness of the
rule follows.
t
u
Lemma 8. Rule 3 is safe.
Proof. Suppose we obtain G0 from G by applying Rule 3. The graph G0 can be
obtained from G by contracting the edge {w, y} and thus G0 is a minor of G.
Hence the pathwidth of G0 is at most the pathwidth of G.
As vertex v is simplicial in G0 , by Lemma 2 we can assume that we have
a path decomposition of optimal width containing a unique bag Xi with v, x
and y. Take a new bag Xi0 with Xi0 = Xi − {v} ∪ {w}, and insert it in the path
decomposition directly after Xi . This gives a path decomposition of G of the
same width.
t
u

B

Safeness of the simplicial components rule

Lemma 9. Let k be an integer. Let G = (V, E) be a graph with modulator S ⊆
V . Suppose that W ⊆ V − S is a simplicial component such that, for each pair of
vertices v, w ∈ NG (W ) ∩ S (including v = w), there are at least 2k + 3 simplicial
components Z 6= W such that pw(G[Z]) ≥ pw(G[W ]) and {v, w} ⊆ NG (Z).
Then pw(G) ≤ k if and only if pw(G − W ) ≤ k.
Proof. Clearly, pw(G) ≤ k implies pw(G − W ) ≤ k.
Now, suppose that the pathwidth of G − W is at most k. Consider a path
decomposition (X1 , . . . , Xr ) of G − W of width at most k. We assume that X1 =
Xr = ∅ for notational convenience.
Let Y = N (W )∩S. If Y = ∅ then W forms a connected component of G, and
the precondition to the lemma ensures that pw(G[W ]) ≤ pw(G−W ) because at
least one simplicial component Z with pw(G[Z]) ≥ pw(G[W ]) remains in G−W ;
hence adding an optimal path decomposition of G[W ] to the decomposition
of G − W does not increase its width, as there is no interaction between the two
parts. In the remainder we may therefore assume that Y 6= ∅.
Note that Y is a clique in G, so by Lemma 1 and the convexity property of
path decompositions there are j1 ≤ j2 , such that Y ⊆ Xj ⇔ j1 ≤ j ≤ j2 , i.e., the
bags that contain all vertices in Y are precisely those with index in j1 , . . . , j2 .
We say that a simplicial component Z is internal to Y if vertices v ∈ Z occur
only in bags Xi with j1 ≤ i ≤ j2 .

Kernel Bounds for Structural Parameterizations of Pathwidth

15

Claim. There is a simplicial component Z in G − W such that pw(G[Z]) ≥
pw(G[W ]) and Z is internal to Y .
Proof. Let v, w ∈ N (W ) ∩ S with v 6∈ Xj1 −1 and w 6∈ Xj2 +1 (possibly v = w).
By assumption, there are at least 2k + 3 simplicial components C such that
pw(G[C]) ≥ pw(G[W ]) and {v, w} ⊆ N (C). If one of these is internal to Y ,
then we are done. Consider such a component C. As it is not internal, there
must be a bag Xi1 with Xi1 ∩ C 6= ∅ and i1 < j1 or j2 < i1 .
Suppose i1 < j1 . By adjacency of C to v, there must be a bag i2 with v ∈ Xi2
and Xi2 ∩ C 6= ∅. As i2 ≥ j1 by choice of v, we have established that C ∩ Xi1 6=
∅, C ∩ Xi2 6= ∅ and i1 < j1 ≤ i2 . By connectivity of C there is a path from a
vertex in C ∩ Xi1 to a vertex in C ∩ Xi2 in G[C]. By tracing this path in the path
decomposition, it is easy to see that C ∩ Xj1 6= ∅. A similar argument shows that
when j2 < i1 then C ∩ Xj2 6= ∅.
Therefore, each of the 2k + 3 simplicial components C has a vertex in Xj1
or in Xj2 . So |Xj1 | ≥ k + 2 or |Xj2 | ≥ k + 2, which contradicts the assumption
that we had a path decomposition of width k.
t
u
Now, let Z be an internal simplicial component of G−W such that pw(G[Z]) ≥
pw(G[W ]). Suppose the pathwidth of G[Z] is `. There must be a bag Xi0 that
contains at least ` + 1 vertices of Z, otherwise (X1 ∩ Z, . . . , Xr ∩ Z) is a path
decomposition of Z of width less than `. Let (Z1 , . . . , Zq ) be a path decomposition of G[Z] of width `, and let (W1 , . . . , Wp ) be a path decomposition of G[W ]
of width at most `.
Now, the following tuple constitutes a path decomposition for G of width at
most k:
(X1 \ Z, . . . , Xi0 −1 \ Z,(Xi0 \ Z) ∪ Z1 , . . . , (Xi0 \ Z) ∪ Zq ,
(Xi0 \ Z) ∪ W1 , . . . , (Xi0 \ Z) ∪ Wp , Xi0 +1 \ Z, . . . , Xr ).
It is obtained by first removing Z from all bags, making p + q copies of Xi0 .
and then adding in successive copies a path decomposition of G[Z] followed by
a path decomposition of G[W ]. As |Xi0 \ Z| ≤ |Xi0 | − (` + 1), this transformation
does not increase the width.
t
u

C

Safeness of the almost simplicial vertex rule

Lemma 5. Let G = (V, E) be a graph and let v ∈ V be an almost simplicial
vertex of degree at least three, with special neighbor w. Let G0 be obtained by
deleting v and by adding a vertex vp,q with neighbors p and q for any p, q ∈ NG (v)
with p 6= q. Then pw(G) = pw(G0 ).
Proof. Let C := N (v) \ {w} and Cv = C ∪ {v}. For ease of reading we denote
by vp,q those vertices where p, q ∈ C and by vp,w those adjacent to w as well as
to some p ∈ C.

16

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

(≥): We first show that pw(G) ≥ pw(G0 ). Let P = (X1 , . . . , Xr ) be a path
decomposition of G. We show how to get a path decomposition for G0 of at most
the same width. Clearly Cv = C ∪{v} is a clique in G, so there must be bags of P
that completely contain Cv ; we call those the Cv -bags (they must be connected).
If w is contained in a Cv -bag, then we may delete v from all other bags while
maintaining a path decomposition
for G. We copy this bag, such that we get a

consecutive chain of |N 2(v)| bags, one for each vertex vp,q and vp,w . In each of
those bags, we replace v by a different vp,q or vp,w vertex. It is easy to see that
this gives a path decomposition for G0 of at most the same pathwidth.
It remains to consider the more difficult case that w is not contained in any Cv
bag. W.l.o.g., let w occur only left of the Cv -bags and let B denote the rightmost
bag containing w. It follows that v occurs in all bags from B to the Cv bags,
in order to represent the edge {v, w} and adhere to connectivity of occurrences.
Let B 0 be the bag directly on the left of the Cv bags (possibly B = B 0 ). It
contains v, so there must be some p̂ ∈ C which is not contained in B 0 , otherwise
it would be a Cv -bag. (Note that this means that w cannot be adjacent to p̂
in G.) Further, let B 00 denote the leftmost Cv -bag.
We make a small modification of P to prepare the replacements that are
necessary to obtain a path decomposition for G0 : We replace in B 0 and all bags
left of it the vertex v by the vertex w, while we simply delete v if w is already
present. At this point we have a path decomposition for G except for not representing the edge {v, w}. The key observation is that v and w share the bag B
before these changes are made, and that all other neighbors of v are in C (and
hence contained in the Cv -bag B 00 ).
Now we will make replacements around the adjacent bags B 0 and B 00 in such
a way that we obtain a path decomposition for G0 . For ease of presentation
let B 0 = X 0 ∪ {w} with p̂ ∈
/ X 0 and let B 00 = C ∪ X ∪ {v}, where X and X 0 are
0
vertex sets. We replace B and B 00 by the following sequence of bags:
1. A copy of B 0 = X 0 ∪ {w}.
2. Bags Ĉ ∪ X ∪ {w} ∪ {vp,w }, one for each vertex vp,w with p ∈ C, with the
rightmost being Ĉ ∪ X ∪ {w} ∪ {vp̂,w }, where Ĉ := C \ {p̂}.
3. A bag C ∪ X ∪ {vp̂,w }.
4. Bags C ∪ X ∪ {vp,q }, one for each vertex vp,q with p, q ∈ C.
It is easy to see that all edges incident with vertices vp,q or vp,w are properly
represented. It can also be verified that connectivity is not violated. The key
points for this are that p̂ ∈
/ X 0 , and that B 0 and B 00 were adjacent bags before
the transformation. Thus after deleting all remaining occurrences of v, we obtain
a path decomposition for G0 of at most the same width.
(≤): Now we show that pw(G) ≤ pw(G0 ). Let P 0 = (X10 , . . . , Xr0 ) be a path
decomposition of G0 . We consider the bags of P 0 that completely contain C, the
C-bags. If there is a vp,w vertex in a C-bag, then replacing all occurrences of
that vertex by v, and deleting all other introduced vertices, we obtain a path
decomposition for G: The reason is that vp,w occurs together with C, but also
together with w. In this case we are done.
Otherwise, if the C-bags contain no vp,w vertex, then this implies that:

Kernel Bounds for Structural Parameterizations of Pathwidth

17

1. All vertices of C must occur also outside of C-bags.
2. The vertex w must occur at least once outside the C-bags.
Assume for contradiction that w does not occur right of the C-bags. This
would imply that all vp,w vertices can only be contained in bags left of the C-bags.
Then however, all vertices p ∈ C must occur left of the C-bags, contradicting
the fact that only the C-bags contain C completely.
Thus, by symmetry, w occurs left and right of the C-bags. Hence, by connectivity of occurrences, w is contained in all C-bags. It follows, that if any C-bags
contains a vp,q vertex, we may replace that vertex by v, and again obtain a
path decomposition for G of the same width; observe that the bag in question
contains N (v) = C ∪ {w}. We will show that there is always a C-bag containing
some vp,q vertex.
Assume for contradiction that no C-bag contains any vp,q vertex. We already
know that each vertex of C must occur outside of the C-bags, and we have used
that not all those vertices can occur left of the C-bags (or not all right of them).
Hence, there are distinct vertices p̂, q̂ ∈ C such that p̂ does not occur right of
the C-bags, and q̂ does not occur left of them. Now, considering the vertex vp̂,q̂
this leads to a contradiction, as that vertex must occur both left and right of
the C-bags, but by assumption it is not contained in any C-bag, contradicting
connectivity of occurrences.
t
u
Remark 1. Lemma 5 has a much simpler proof for the special case of v being
simplicial. It is easy to see that the replacement of v does not generalize to the
case of more special neighbors: Consider the 3-claw which has pathwidth one.
Making an analogous replacement for the center of the claw, would create a cycle
of length six which has pathwidth two. In general, when there is more than one
special neighbor, then the modification creates a larger clique minor, than what
the degree of v would imply.
Remark 2. It can be easily seen that even the special case of simplicial vertices
is not correct for treewidth. Application on one vertex of a clique of size four
(and treewidth three) gives a graph of treewidth two.

D

Hardness for Pathwidth and Treewidth Parameterized
by a Modulator to a Single Clique

In this section, we give the proof that Treewidth and Pathwidth, parameterized by a modulator to a single clique do not have a polynomial kernel unless
NP ⊆ coNP/poly. More precisely, we show this when we additionally restrict our
input to co-bipartite graphs. As the treewidth equals the pathwidth for these
graphs, the same proof can be used for the pathwidth as well as the treewidth
version.
A tree decomposition of a graph G = (V, E) is a pair ({Xi | i ∈ I}, T = (I, F ))
with {Xi | i ∈ I} a family of subsets of V , and T a tree on edge set F , such that
S
– i∈I Xi = V .

18

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

– For all {v, w} ∈ E, there is an i ∈ I with v, w ∈ Xi .
– For all v ∈ V , the set Iv = {i ∈ I | v ∈ Xi } induces a subtree of T .
The sets Xi are called the bags of the tree decomposition. The width of a tree
decomposition ({Xi | i ∈ I}, T = (I, F )) is maxi∈I |Xi | − 1, and the treewidth
of G is the minimum width of a tree decomposition of G.
If we have a weight function w : V (G) → N then the weighted
P width of a tree
decomposition ({Xi | i ∈ I}, T = (I, F )) of G equals maxi∈I v∈Xi w(i), and the
weighted treewidth of G is the minimum weighted width of a tree decomposition
of G. Observe that, contrary to the case of normal treewidth, we do not subtract
one; hence the weighted treewidth of a tree in which w(v) = 1 for all vertices is
two, rather than one.
An alternative characterization of treewidth is with help of elimination orderings. An elimination ordering of a graph is a permutation of its vertices.
To eliminate a vertex v corresponds to making its neighbors into a clique and
then deleting v. Given an elimination ordering π of a graph G, we obtain a sequence of graphs by eliminating the vertices of G in the order of π. The following
proposition is well known, see e.g., [3].
Proposition 1. Graph G has treewidth at most k if and only if G has an elimination ordering in which each vertex has degree at most k when it is eliminated.
The kernel lower bound is proven using the framework of cross-composition,
which relies on the following notions.
Definition 1 (Polynomial equivalence relation [6]). An equivalence relation R on Σ ∗ is called a polynomial equivalence relation if the following two
conditions hold:
1. There is an algorithm that given two strings x, y ∈ Σ ∗ decides whether x
and y belong to the same equivalence class in (|x| + |y|)O(1) time.
2. For any finite set S ⊆ Σ ∗ the equivalence relation R partitions the elements
of S into at most (maxx∈S |x|)O(1) classes.
Definition 2 (Cross-composition [6]). Let L ⊆ Σ ∗ be a set and let Q ⊆
Σ ∗ × N be a parameterized problem. We say that L cross-composes into Q if
there is a polynomial equivalence relation R and an algorithm which, given t
strings x1 , x2 , . . . , xt belonging to the same equivalence
Pt class of R, computes an
instance (x∗ , k ∗ ) ∈ Σ ∗ × N in time polynomial in i=1 |xi | such that:
1. (x∗ , k ∗ ) ∈ Q ⇔ xi ∈ L for some 1 ≤ i ≤ t,
2. k ∗ is bounded by a polynomial in maxti=1 |xi | + log t.
Theorem 3 ([6]). If some set L is NP-hard under Karp reductions and L crosscomposes into the parameterized problem Q then there is no polynomial kernel
for Q unless NP ⊆ coNP/poly.
We start with a number of results on (weighted) treewidth that are folklore
or can easily be proved with standard arguments (see, e.g., [17]).

Kernel Bounds for Structural Parameterizations of Pathwidth

19

Definition 3. Consider a graph G weighted by function w, and an elimination
ordering π on the vertices of G. The cost of π is the maximum over all vertices v ∈ V (G) of the weight of N [v] at the time that v is eliminated by π.
Proposition 2. Graph G has weighted treewidth at most k if and only if there
is an elimination ordering of G of cost at most k.
Proposition 3 (Cf. [1]). Let G be a co-bipartite graph on bipartition V (G) :=
˙ weighted by function w. For every elimination ordering π on G there is
A∪B
an elimination ordering π 0 which does not cost more than π, such that π first
eliminates all vertices of A, and finishes by eliminating all vertices of B.
Proposition 4. Let G be a graph with weight function w containing two adjacent vertices v, w such that NG [v] ⊆ NG [w]. Let π be an elimination ordering
of G which eliminates w before v, and let the ordering π 0 be obtained by updating π such that it eliminates v just before w. Then the cost of π 0 is not higher
than the cost of π.
Proposition 5. Let G be a graph with positive integral vertex weights. Let G0 be
the graph obtained from G by iterating the following procedure. As long as there
is a vertex v with weight more than one, subtract one from the weight of v and
add a new vertex v 0 of weight 1 and with neighborhood N [v]. Then the treewidth
of G0 equals the weighted treewidth of G0 minus one.
Theorem 4. Treewidth parameterized by a modulator to a single
clique does not admit a polynomial kernelization unless NP ⊆ coNP/poly.
Proof. We show that the NP-complete Cutwidth3 problem cross-composes into
TWMSC. We start by defining a polynomial equivalence relationship R. Fix an
encoding of instances of Cutwidth3, and choose R such that all strings which
do not encode a valid instance are equivalent. For the strings which do encode
a valid instance, define two instances (G1 , k1 ) and (G2 , k2 ) to be equivalent if
all of the following hold: k1 = k2 , |V (G1 )| = |V (G2 )|, |E(G1 )| = |E(G2 )|, and
for each integer i ∈ {1, 2, 3} the number of degree-i vertices in G1 and G2 is the
same. Since a set of valid instances on at most n vertices each is partitioned into
at most n × n × n3 equivalence classes, this constitutes a polynomial equivalence
relationship.
We now show how to cross-compose a set of instances of Cutwidth3 which
belong to the same equivalence class of R. If all instances are malformed, then
this can be recognized in polynomial time and we simply output a constant-size
no-instance. So in the remainder we may assume that all input instances (G1 , k1 ),
. . . , (Gt , kt ) are well-formed and belong to the same equivalence class; in particular k1 = . . . = kt = k and |V (G1 )| = . . . = |V (Gt )| = n. Order the vertices
within each graph by increasing degree, breaking ties arbitrarily. The choice
of R, together with the fact that each Gi has maximum degree 3, guarantees
that each graph has the same number of vertices of each degree.
Since Cutwidth on a graph on n vertices can be solved in O∗ (2n ) time [5,
Theorem 10], we may assume that n ≥ log t. For if n < log t then applying the

20

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

algorithm by Bodlaender et al. [5] consecutively on each instance can be done in
time which is polynomial in the total input size (which is at least t); we could
then output a constant-size instance with the appropriate answer as the output
of the cross-composition. For similar reasons we may assume n ≥ 2. Finally, we
may assume that the number of input instances t is a power of 2 since we can
duplicate some instances without changing the value of the OR, increasing the
input size by at most a factor two.
To construct the instance of TWMSC that encodes the OR of the input
instances, we use a two-stage process for the ease of presentation. We first show
that the OR of the input instances can be encoded into an instance of Weighted
Treewidth parameterized by a modulator to a single clique on a cobipartite graph with partite sets A and B, such that the total weight of the set B
is polynomial in n + log t. The set B will be the modulator, which is valid since
removing the partite set B from a co-bipartite graph leaves a clique. We then
use Proposition 5 to obtain an equivalent instance of TWMSC, and since the
total weight of B is sufficiently small this produces an instance of TWMSC that
encodes the OR of the input instances, and has a modulator to a single clique
whose size is polynomial in n + log t.
We now construct a graph G∗ and weight function w such that computing
the weighted treewidth of G∗ corresponds to computing the OR of the instances
of Cutwidth3. The construction is based on the NP-completeness proof for
Treewidth by Arnborg et al. [1]. The graph G∗ will be co-bipartite with partite
˙ and A and B are cliques in G∗ . The graph G∗
sets A and B, so V (G∗ ) := A∪B
is defined as follows:
– For each input graph Gi with i ∈ [t], for each vertex j ∈ V (Gi ), we add
a vertex vi,j of weight n3 to A which corresponds to vertex j. For a given
value of j ∈ [n] we say that all vertices vi,j (for all relevant values of i)
are A-representatives of node j. We also add a dummy vertex di for each
instance i ∈ [t] to A of weight n6 . We turn A into a clique.
– The vertex set B consists of three parts: the instance selector vertices BI ,
the node representatives BN and the edge representatives BE .
• The instance selector vertices will be used to encode the binary representation of instance numbers. Since we assumed t to be a power of two,
we need log t bits to encode an instance number and therefore 2 log t
vertices are used to represent all possible bit values for log t positions.
So BI := {aq , bq | q ∈ [log t]}. Each vertex in BI has weight n5 .
We connect the vertices of BI to the vertices of A as follows. We make a
vertex vi,j in A (which corresponds to instance i) adjacent to the instance
selector vertices of the bit values of the binary representation of i. So
for q ∈ [log t], if the q-th bit of number i is 1 then we make vi,j adjacent
to aq , and if the bit is 0 then we make the vertex adjacent to bq . The
adjacency from dummy vertices di to the vertices of BI is defined exactly
the same through the binary representation of i.
• The node representatives BN contain a vertex for each node number
in [n]. Recall that all input graphs have the same number of vertices

Kernel Bounds for Structural Parameterizations of Pathwidth

21

of each degree, and that we sorted the vertices by degree. When we
write deg(j) for j ∈ [n] we will therefore take this to mean the value d
such that in each input graph, each vertex j has degree d. For each j ∈ [n]
we add a vertex xj to the set BN and give it weight n3 − deg(j). The
vertex xj is said to be the (unique) B-representative of node j.
The adjacency between BN and A is simple: for each j ∈ [n] we make
all A-representatives of j adjacent to the single B-representative of j,
and we make all the nodes in BN adjacent to all the dummy vertices di
for i ∈ [t].
• The edge representatives BE contain one vertex for
 each possible edge in
an undirected n-vertex graph. So for {v, w} ∈ [n]
2 we have a vertex ev,w
of weight two. Vertex ev,w is adjacent to an A-representative vi,j if instance Gi contains the edge {v, w} and j = v or j = w, i.e., the edge
representative ev,w is adjacent to instance i’s A-representatives of the
endpoints of the edge, provided that instance i actually contains the
edge. Additionally, all vertices of BE are adjacent to all dummy vertices di for i ∈ [t].
The construction is completed by turning B := BI ∪ BN ∪ BE into a clique.
We set k 0 := t · (n4 + n6 ) + n3 + n5 log t + k.
To complete the first stage, we need to prove that (G∗ , w) has weighted
treewidth at most k 0 if and only if at least one of the input graphs Gi has
cutwidth at most k. Before proving this claim, we establish some properties of
the constructed instance (G∗ , w, k 0 ).
Claim 1. Let S := {vi,j | j ∈ [n]} for a given instance number i ∈ [t] be the
subset of the vertices in A corresponding to instance i. Let π be a permutation
of S. Consider the process of eliminating the vertices in S from graph G∗ in the
order given by π, and let E-weight(Sπ(j) ) be the total weight of N [Sπ(j) ] when
eliminating the vertex π(j) for j ∈ [n]. Then E-weight(Sπ(j) ) = t · (n4 + n6 ) +
n3 + n5 log t + `, where ` := |{{u, v} ∈ E(Gi ) | π(u) ≤ j < π(v)}|.
Proof. The intuition behind the proof is that the elimination process has two
effects on the weight of neighbors of some vertex v ∈ A: on the one hand,
eliminated vertices in A are essentially replaced by the representatives in BN
in the neighborhood of v, which have slightly smaller weight than the originals;
the difference is exactly equal to the degree of the corresponding vertex. On
the other hand, the representative of any edge in BE will be added to those
neighborhoods, once one of the endpoints is eliminated; recall that those edges
contribute a weight of two. Thus, when reaching the first endpoint of an edge, the
weight increases by one (by the degree contribution); when reaching the second
endpoint this increase is canceled. Together this leads to the contribution of `
in E-weight(Sπ(j) ). This idea was used by Arnborg et al. [1] in their NPcompleteness proof for Treewidth.
Armed with this intuition, let us proceed with the proof. By definition of G∗ ,
all vertices in S have the same set of neighbors in BI so elimination of vertices
from S does not affect the adjacency of other vertices in S to BI . Consider a

22

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

vertex vi,j in S. From the construction of G∗ it follows that initially, the only
vertex of S which is adjacent to the B-representative of j, is the vertex vi,j . Since
we only eliminate vertices from S, it follows that a vertex in S is only adjacent
to the B-representative of a node number j if that vertex is itself the unique
A-representative of j in S, or if the A-representative of j in S was eliminated
earlier. Let us use these observations to prove the claim.
For an arbitrary value of j ∈ [n] we consider the closed neighborhood of
the vertex Sπ(j) just before it is eliminated. We will study the neighborhood
of Sπ(j) in the sets A, BI , BN and BE consecutively. For convenience, define
E-weightX (Sπ(j) ) for X ⊆ V (G∗ ) as the total weight of N [Sπ(j) ]∩X when Sπ(j)
is eliminated.

Neighbors in A. Since A is a clique and S ⊆ A, vertex Sπ(j) is initially adjacent to all vertices of A. Since the only vertices which are eliminated are
those in S corresponding to instance i, vertex Sπ(j) will be adjacent to all
vertices for other instances, i.e., to vi0 ,j for i0 6= i and j ∈ [n], for a total
weight of E-weightA\S (Sπ(j) ) = (t−1)n·n3 . Vertex Sπ(j) is also adjacent to
all t dummy vertices for a weight of n6 each. The remaining vertices of A are
those in S, and Sπ(j) is adjacent to those which are not already eliminated.
Hence there are n − j + 1 vertices in S which are in the closed neighborhood of Sπ(j) just before it is eliminated. These have weight n3 (n − j + 1)
so E-weightA (Sπ(j) ) = (t − 1)n4 + t · n6 + n3 (n − j + 1).
Neighbors in BI . Since the neighborhood of Sπ(j) in BI is not changed by the
eliminations, vertex Sπ(j) has exactly log t neighbors in BI with weight n5
each so E-weightBI (Sπ(j) ) = n5 log t.
Neighbors in BN . By construction of G∗ , vertex Sπ(j) is adjacent to the unique
node in BN which is the B-representative for the vertex for which Sπ(j) is
an A-representative. Initially, Sπ(j) is not adjacent to other vertices of BN .
For each vertex 1 ≤ j 0 < j which was eliminated before j, vertex Sπ(j)
has become adjacent to the vertex in BN which is B-representative for the
vertex to which Sπ(j 0 ) is the A-representative. So E-weightBN (Sπ(j) ) =
Pj
3
0
j 0 =1 (n − deg(j )).
Neighbors in BE . Initially, vertex Sπ(j) is adjacent to the edge-representative
vertices in BE for which Sπ(j) represents an endpoint, so to deg(j) vertices
with weight two each. For each vertex Sπ(j 0 ) with 1 ≤ j 0 < j which is
eliminated before π(j), Sπ(j) becomes adjacent to the edge-representatives
in BE for edges which are incident on Sπ(j 0 ) in graph Gi . This shows that
S
E-weightBE (Sπ(j) ) := 2| 1≤j 0 ≤j {eu,v | {u, v} ∈ E(Gi )∧(j 0 = u∨j 0 = v)}|.
We can now sum up the weights of the members of the closed neighborhood
N [Sπ(j) ] in each of the respective subsets to establish that E-weight(Sπ(j) )

Kernel Bounds for Structural Parameterizations of Pathwidth

23

equals:
A

BI ∪BN ∪BE

E-weight(Sπ(j) ) + E-weight(Sπ(j) )

=[(t − 1)n4 + t · n6 + n3 (n − j + 1)] + [n5 log t] + 

j
X


(n3 − deg(j 0 )) +

j 0 =1

2

[

{eu,v | {u, v} ∈ E(Gi ) ∧ (j 0 = u ∨ j 0 = v)}

1≤j 0 ≤j

=t · (n4 + n6 ) + n3 + n5 log t −

j
X

(deg(j 0 ))+

j 0 =1

2

[

{eu,v | {u, v} ∈ E(Gi ) ∧ (j 0 = u ∨ j 0 = v)}

1≤j 0 ≤j

To simplify this further, we define E1 as the set of edges of Gi which have
one endpoint among the vertices in the range [1 . . . j], and E2 as the edges
of Gi with both endpoints among [1 . . . j]. Observe that these definitions imply
Pj
S
that j 0 =1 deg(j 0 ) = |E1 | + 2|E2 | and | 1≤j 0 ≤j {eu,v | {u, v} ∈ E(Gi ) ∧ (j 0 =
u ∨ j 0 = v)}| = |E1 | + |E2 |. We continue the derivation:
=t · (n4 + n6 ) + n3 + n5 log t − (|E1 | + 2|E2 |) + 2(|E1 | + |E2 |)
=t · (n4 + n6 ) + n3 + n5 log t + |E1 |.
Now observe that by definition, |E1 | is the number of edges which have one
endpoint at or to the left of j, and the other endpoint to the right of j, and
hence this is exactly the value of ` as defined in the statement of the claim; this
concludes the proof of Claim 1.
t
u
The preceding claim relates the cost of the first n eliminations of an ordering
of G∗ to the cutwidth of an instance i, provided that the ordering starts by
eliminating the A-representatives of instance i. The next claim shows that these
first n eliminations essentially dominate the cost of elimination orderings with
this structure.
Claim 2. Let S, i, π and E-weight be as defined in Claim 1. Consider an elimination ordering for G∗ which starts by eliminating S in the order given by π,
then eliminates the dummy di corresponding to instance i, and eliminates the remaining vertices in arbitrary order. The cost of π ∗ is maxj∈[n] E-weight(Sπ(j) ).
Proof. By Claim 1, the maximum weight of a closed neighborhood when eliminating the vertices from S is exactly maxj∈[n] E-weight(Sπ(j) ) ≥ t · (n4 + n6 ) +
n3 + n5 log t. We show that after elimination of S, eliminating the dummy di
and all remaining vertices does not incur a cost higher than this.

24

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

Consider the weight of the closed neighborhood of the dummy vertex di after
the n vertices from S have been eliminated. At that stage, di is adjacent to
all vertices which are left in A, to all vertices of BN , some vertices of BE , and
to the log t vertices in BI which correspond to the binary representation of the
number i. Since the total weight of BN is not more than n·n3 , the weight of N [di ]
when di is eliminated is bounded by t(n4 +n6 )−n4 +n·n3 +n5 log t+2 n2 , which
is at most t(n4 + n6 ) + n3 + n5 log t and so does not exceed the cost incurred for
the first n vertices.
After di and S have been eliminated from the graph, the total weight
of the

remaining vertices is at most (t − 1)(n4 + n6 ) + 2n5 log t + n4 + 2 n2 , which is
bounded by t(n4 + n6 ) + n3 + n5 log t as we assumed n ≥ log t at the beginning of
the proof. Hence the cost of this elimination ordering π ∗ is dominated by the cost
of eliminating the first n vertices and is therefore maxj∈[n] E-weight(Sπ(j) ). t
u
Having shown how the cost of specific types of elimination orderings of G∗
corresponds to the cutwidth of one particular input instance, we proceed to show
that there is always an optimal ordering of this type.
Claim 3. If there is an elimination ordering of (G∗ , w) of cost at most k 0 , then
there is such an ordering which starts by eliminating all vertices in the set {vi,j |
j ∈ [n]} for some i ∈ [t], i.e., there is an ordering which first eliminates all
A-representatives corresponding to one particular input instance Gi .
Proof. The proof contains of two parts. We first give a canonical elimination
ordering of bounded cost, and then use a replacement argument which compares
the cost of this canonical ordering to an ordering which does not match the form
in the statement of the lemma.
Define a canonical elimination π ∗ as follows. It starts with the sequence
v1,1 , v1,2 , . . . , v1,n , then eliminates dummy d1 , and finally eliminates the rest of
the vertices in arbitrary order. By Claim 2 the cost incurred by ordering π ∗ is
maxj∈[n] E-weight(Sπ(j) ). Observe that the cutwidth of graph G1 under any
ordering does not exceed the number of its edges, which is at most 3n/2 since G1
has maximum degree at most three. Hence we find that the term ` in the expression for E-weight given by Claim 1 is bounded by 3n/2. Using Claim 1 we
therefore find that the cost of this canonical elimination ordering π ∗ is bounded
by t · (n4 + n6 ) + n3 + n5 log t + 3n/2.
To complete the proof, the second part will show that any elimination ordering whose form does not match that in the statement of the claim, has cost as
least as much as the canonical ordering. So consider any elimination ordering π
of (G∗ , w) of cost at most k 0 . By Proposition 3 there is an optimal-cost elimination ordering which first eliminates all of A, so assume without loss of generality
that π first eliminates all vertices of A. Since the construction of G∗ guarantees
that for all i ∈ [t], all vertices vi,j of A satisfy NG∗ [vi,j ] ⊆ NG∗ [di ], Proposition 4
shows that we may assume without loss of generality that for all i ∈ [t], the vertices vi,j for j ∈ [n] are eliminated by π earlier than di ; hence the first n vertices
eliminated by π are not dummy vertices. If the first n vertices correspond to the
same instance then we are done; hence in the remainder we may assume this

Kernel Bounds for Structural Parameterizations of Pathwidth

25

is not the case. Consider the first index 1 < j ≤ n such that all vertices π(j 0 )
for 1 ≤ j 0 < j correspond to the same instance i (i.e., they are of the form vi,j 00
for j 00 ∈ [n]) and π(j) corresponds to instance i0 with i 6= i0 . Let us consider the
neighborhood of the vertex π(j) when it is eliminated.
By construction of G∗ , vertex π(j) corresponding to instance i0 is adjacent
to the vertices in BI which correspond to the binary representation of i0 . Since
vertex π(1) was eliminated before π(j), and since vertices π(1) and π(j) are
adjacent in G∗ because they are both members of the clique A, after elimination
of π(1) the vertex π(j) has become adjacent to all neighbors of π(1). Since π(1) is
adjacent to the vertices of BI corresponding to the binary representation of i, and
since the binary representations of i and i0 must differ in at least one position, the
number of neighbors of π(j) in BI at the time it is eliminated is at least 1 + log t,
and they have weight n5 each. Since π(j) is also adjacent to all vertices of A
except the j − 1 vertices of weight n3 which were eliminated earlier, this shows
that the weight of the closed neighborhood of π(j) at the time it is eliminated
is at least t(n4 + n6 ) − j · n3 + (1 + log t)n5 . Using that j ≤ n and n ≥ 2 (which
we assumed in the beginning the proof of the theorem), it now follows that the
weight of π(j) at the time it is eliminated is at least as much as the cost of the
canonical elimination ordering. Hence the canonical elimination ordering which
we defined earlier has cost no more than π, and since the canonical ordering
starts by eliminating v1,1 , v1,2 , . . . , v1,n this concludes the proof of Claim 3. t
u
We are now finally ready to prove that (G∗ , w) has weighted treewidth at
most k 0 if and only if at least one of the input graphs Gi has cutwidth at most k.
First assume that (G∗ , w) has weighted treewidth at most k 0 . By Proposition 2
this implies that there is an elimination ordering π of G∗ with cost at most k 0 .
By Claim 3 we may assume that there is an instance number i∗ ∈ [t] such
that π starts by eliminating all vertices in the set S := {vi∗ ,j | j ∈ [n]}. As
the cost of π is at most k 0 , the weight of the closed neighborhood of a vertex
in S at the time it is eliminated does not exceed k 0 . By Claim 1 this proves
that maxj∈[n] E-weight(Sπ(j) ) ≤ k 0 . Plugging in the value for k 0 and the expression for E-weight obtained in the mentioned claim, and cancelling terms
on both sides, we find that maxj∈[n] |{{u, v} ∈ E(Gi∗ ) | π(u) ≤ j < π(v)}| ≤ k
which proves that Gi∗ has cutwidth at most k, when using the ordering on S
induced by π.
For the reverse direction, assume that Gi∗ has cutwidth at most k, and let π ∗
be an ordering which achieves this cutwidth. Build an elimination ordering for G∗
by first eliminating the vertices of S := {vi∗ ,j | j ∈ [n]} in the order induced
by π ∗ , then eliminating the dummy di∗ , and then eliminating the remaining
vertices in arbitrary order. By Claim 2 the cost of this ordering is dominated by
the cost of eliminating the vertices of S, which is maxj∈[n] E-weight(Sπ(j) ). If
ordering π ∗ achieves cutwidth at most k on Gi∗ , then evaluating the expression
for E-weight given by Claim 1 proves that the cost of π is at most k 0 . Using
Proposition 2 this proves that (G∗ , w) has weighted treewidth at most k 0 .
To complete the cross-composition of Cutwidth3 into TWMSC, we can
transform the weighted graph (G∗ , w) to the unweighted graph Ĝ using the

26

Hans L. Bodlaender, Bart M. P. Jansen, and Stefan Kratsch

transformation of Proposition 5. Since this transformation duplicates the closed
neighborhoods of vertices, it results in a co-bipartite graph since the cliques A
and B of G∗ are just transformed into larger cliques in Ĝ. Let B̂ be the clique
in Ĝ which results from the transformation of clique B in G∗ . The size of B̂ is
bounded by the maximum weight of a vertex in B (under w) times the size of B.
Since both are polynomial in n + log t, this shows that the size of B̂ is bounded
polynomially in n + log t. Now consider the instance of TWMSC which asks if Ĝ
with the modulator B̂ to a single clique (because Ĝ is co-bipartite and B̂ is one
of the partite sets) has treewidth at most k 0 − 1; by the equivalence between
the weighted treewidth of the original graph, and the normal treewidth of the
result of the transformation, our constructed instance is equivalent to the OR
of the input instances of Cutwidth3. The size of the modulator, which is the
parameter of the TWMSC instance, is polynomial in n + log t. This concludes
the cross-composition; Theorem 4 follows by applying Theorem 3.
t
u
Since the pathwidth of a co-bipartite graph equals its treewidth [14] and the
graph formed by the cross-composition is co-bipartite, we obtain the following
corollary.
Corollary 1. Pathwidth parameterized by a modulator to a single
clique does not admit a polynomial kernel unless NP ⊆ coNP/poly.

